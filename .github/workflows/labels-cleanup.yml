name: Labels Cleanup (after DB CI)

on:
  workflow_run:
    workflows: ["CI (DB)"]
    types: [completed]

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Cleanup labels on PRs for this run
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const {owner, repo} = context.repo;
            const runId = context.payload.workflow_run.id;
            // Find PRs associated with this run (head commit)
            const headSha = context.payload.workflow_run.head_sha;
            const prs = await github.rest.repos.listPullRequestsAssociatedWithCommit({owner, repo, commit_sha: headSha});
            if (!prs.data.length) {
              core.info('No PR found for head sha ' + headSha);
              return;
            }
            // Load blocking labels config
            let blocking = ['plans:changed','drift:detected','docs:outdated'];
            const autoRemove = new Set(['plans:changed','drift:detected']);
            try {
              const raw = fs.readFileSync(path.join(process.cwd(), '.github', 'ci-blocking-labels.json'), 'utf8');
              const cfg = JSON.parse(raw);
              if (Array.isArray(cfg)) blocking = cfg; else if (cfg && Array.isArray(cfg.blocking)) blocking = cfg.blocking;
            } catch (e) {}
            // For each PR, analyze comments from db-ci report markers
            for (const pr of prs.data) {
              const issue_number = pr.number;
              const comments = await github.rest.issues.listComments({owner, repo, issue_number, per_page: 100});
              const plans = comments.data.find(c => c.body && c.body.includes('<!-- plans-report -->'));
              const drift = comments.data.find(c => c.body && c.body.includes('<!-- drift-report -->'));
              let plansOk = false, driftOk = false;
              if (plans) {
                plansOk = /\bNo plan changes detected\./.test(plans.body);
              } else {
                // absent comment => assume ok to avoid blocking forever
                plansOk = true;
              }
              if (drift) {
                driftOk = /\bNo schema drift detected\./.test(drift.body);
              } else {
                driftOk = true;
              }
              // If both OK, remove blocking labels and optionally auto-approve
              if (plansOk && driftOk) {
                try {
                  const issue = await github.rest.issues.get({owner, repo, issue_number});
                  const labels = issue.data.labels.map(l => l.name);
                  for (const lab of labels) {
                    if (blocking.includes(lab) && autoRemove.has(lab)) {
                      try {
                        await github.rest.issues.removeLabel({owner, repo, issue_number, name: lab});
                        core.info(`Removed label ${lab} from #${issue_number}`);
                      } catch (e) {
                        core.warning('Could not remove label ' + lab + ': ' + e.message);
                      }
                    }
                  }
                } catch (e) {
                  core.warning('Failed to get labels for PR #' + issue_number + ': ' + e.message);
                }
                // Optional: auto-approve if no blocking labels remain
                try {
                  const updated = await github.rest.issues.get({owner, repo, issue_number});
                  const left = updated.data.labels.map(l => l.name).filter(l => blocking.includes(l));
                  if (!left.length) {
                    await github.rest.pulls.createReview({
                      owner, repo, pull_number: issue_number,
                      event: 'APPROVE',
                      body: 'All blocking checks green. Auto-approval by Labels Cleanup.'
                    });
                  }
                } catch (e) {
                  core.warning('Failed to auto-approve PR #' + issue_number + ': ' + e.message);
                }
              } else {
                core.info(`PR #${issue_number} still has issues (plansOk=${plansOk}, driftOk=${driftOk}).`);
              }
            }
