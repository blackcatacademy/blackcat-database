name: PR Override Commands

on:
  issue_comment:
    types: [created]

jobs:
  override:
    if: github.event.issue.pull_request != null
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Handle /override and /unoverride
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const {owner, repo} = context.repo;
            const issue_number = context.issue.number;

            const body = (context.payload.comment && context.payload.comment.body || '').trim();
            const author = context.payload.comment && context.payload.comment.user && context.payload.comment.user.login;

            // Commands supported:
            // /override           -> add override label
            // /unoverride         -> remove override label
            // @bot override       -> add override label (alias)
            const isOverride = /^\/override\b/i.test(body) || /@bot\s+override/i.test(body);
            const isUnoverride = /^\/unoverride\b/i.test(body);

            if (!isOverride && !isUnoverride) {
              core.info('No override command found.');
              return;
            }

            // Load config
            let blocking = ['plans:changed','drift:detected','docs:outdated'];
            let overrides = { users: [], labels: ['override:allowed'] };
            try {
              const raw = fs.readFileSync(path.join(process.cwd(), '.github', 'ci-blocking-labels.json'), 'utf8');
              const cfg = JSON.parse(raw);
              if (Array.isArray(cfg)) {
                blocking = cfg;
              } else if (cfg && typeof cfg === 'object') {
                if (Array.isArray(cfg.blocking)) blocking = cfg.blocking;
                if (cfg.overrides && typeof cfg.overrides === 'object') {
                  overrides.users = Array.isArray(cfg.overrides.users) ? cfg.overrides.users : [];
                  overrides.labels = Array.isArray(cfg.overrides.labels) ? cfg.overrides.labels : ['override:allowed'];
                }
              }
            } catch (e) {
              core.info('Using default labels; missing or invalid config: ' + e.message);
            }

            // Check permissions: allowlisted user OR has write/admin collab permission
            let hasPerm = false;
            try {
              const perm = await github.rest.repos.getCollaboratorPermissionLevel({owner, repo, username: author});
              const level = perm.data && perm.data.permission;
              hasPerm = level === 'admin' || level === 'write' || level === 'maintain';
            } catch (e) { /* ignore */ }
            const allowedUser = overrides.users.includes(author);
            if (!(hasPerm || allowedUser)) {
              core.setFailed(`User @${author} is not allowed to use override commands.`);
              return;
            }

            // Choose first override label from config
            const overrideLabel = overrides.labels[0] || 'override:allowed';

            if (isOverride) {
              await github.rest.issues.addLabels({owner, repo, issue_number, labels: [overrideLabel]});
              try { await github.rest.reactions.createForIssueComment({owner, repo, comment_id: context.payload.comment.id, content: 'rocket'}); } catch(e) {}
              core.info(`Added label ${overrideLabel}`);
              return;
            }
            if (isUnoverride) {
              try { await github.rest.issues.removeLabel({owner, repo, issue_number, name: overrideLabel}); } catch (e) { core.info('Label not present'); }
              try { await github.rest.reactions.createForIssueComment({owner, repo, comment_id: context.payload.comment.id, content: 'eyes'}); } catch(e) {}
              core.info(`Removed label ${overrideLabel}`);
              return;
            }
