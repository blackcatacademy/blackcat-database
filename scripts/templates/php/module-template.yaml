Content: |-
  <?php
  declare(strict_types=1);
  
  namespace [[NAMESPACE]];
  
  use BlackCat\Database\SqlDialect;
  use BlackCat\Database\Contracts\ModuleInterface;
  use BlackCat\Database\Support\SqlIdentifier;
  use BlackCat\Database\Support\SqlDirectoryRunner;
  use BlackCat\Database\Support\SchemaIntrospector;
  use [[DATABASE_FQN]] as Database;
  
  final class [[CLASS]] implements ModuleInterface
  {
      public function name(): string { return 'table-[[TABLE]]'; }
      public function table(): string { return '[[TABLE]]'; }
      public function version(): string { return '[[VERSION]]'; }
  
      /** @return string[] */
      public function dialects(): array { return [[DIALECTS_ARRAY]]; }
      /** @return string[] */
      public function dependencies(): array { return [[DEPENDENCIES_ARRAY]]; }
  
      public static function contractView(): string { return '[[VIEW]]'; }
  
      public function install(Database $db, SqlDialect $d): void
      {
          // 1) Run schema files from ../schema for the dialect (NNN_*.sql order respected)
          SqlDirectoryRunner::run($db, $d, __DIR__ . '/../schema');
  
          // 2) Contract view = SELECT * FROM <table>
          $table = SqlIdentifier::qi($db, $this->table());
          $view  = SqlIdentifier::qi($db, self::contractView());
  
          if ($d->isMysql()) {
              $createViewSql = <<<'SQL'
  [[CONTRACT_VIEW_SQL_MYSQL]]
  SQL;
          } else {
              $createViewSql = <<<'SQL'
  [[CONTRACT_VIEW_SQL_POSTGRES]]
  SQL;
          }
  
          if (\class_exists('\\BlackCat\\Database\\Support\\DdlGuard')) {
              (new \BlackCat\Database\Support\DdlGuard($db, $d))->applyCreateView($createViewSql);
          } else {
              // Prefer CREATE OR REPLACE VIEW (gentle on dependencies)
              $db->exec($createViewSql);
          }
  
      }
  
      public function upgrade(Database $db, SqlDialect $d, string $from): void
      {
          // Optional: generator may place module-specific upgrade steps here (e.g., data migrations).
      }
  
      /** Does not drop the table, only the contract (view). */
      public function uninstall(Database $db, SqlDialect $d): void
      {
          $qiV = SqlIdentifier::qi($db, self::contractView());
          try {
              $db->exec("DROP VIEW IF EXISTS {$qiV}" . ($d->isMysql() ? "" : " CASCADE"));
          } catch (\Throwable) {
              // swallow
          }
      }
  
      public function status(Database $db, SqlDialect $d): array
      {
          $table = $this->table();
          $view  = self::contractView();
  
          $hasTable = SchemaIntrospector::hasTable($db, $d, $table);
          $hasView  = SchemaIntrospector::hasView($db, $d, $view);
  
          // Quick index/FK check â€“ generator injects names (case-sensitive per DB)
          $expectedIdx = [[INDEX_NAMES_ARRAY]];
          if ($d->isMysql()) {
              // Drop PG-only index naming patterns (e.g., GIN/GiST)
              $expectedIdx = array_values(array_filter(
                  $expectedIdx,
                  static fn(string $n): bool => !str_starts_with($n, 'gin_') && !str_starts_with($n, 'gist_')
              ));
          }
          $expectedFk  = [[FK_NAMES_ARRAY]];
  
          $haveIdx = $hasTable ? SchemaIntrospector::listIndexes($db, $d, $table)     : [];
          $haveFk  = $hasTable ? SchemaIntrospector::listForeignKeys($db, $d, $table) : [];
  
          $missingIdx = array_values(array_diff($expectedIdx, $haveIdx));
          $missingFk  = array_values(array_diff($expectedFk, $haveFk));
  
          return [
              'table'       => $hasTable,
              'view'        => $hasView,
              'missing_idx' => $missingIdx,
              'missing_fk'  => $missingFk,
              'version'     => $this->version(),
          ];
      }
  
      public function info(): array
      {
          return [
              'table'       => $this->table(),
              'view'        => self::contractView(),
              'columns'     => Definitions::columns(),
              'version'     => $this->version(),
              'dialects'    => [[DIALECTS_ARRAY]],
              'indexes'     => [[INDEX_NAMES_ARRAY]],
              'foreignKeys' => [[FK_NAMES_ARRAY]],
          ];
      }
  }
Tokens:
  - NAMESPACE
  - CLASS
  - TABLE
  - VIEW
  - VERSION
  - DIALECTS_ARRAY
  - DEPENDENCIES_ARRAY
  - INDEX_NAMES_ARRAY
  - FK_NAMES_ARRAY
  - DATABASE_FQN
  - CONTRACT_VIEW_SQL_MYSQL
  - CONTRACT_VIEW_SQL_POSTGRES
File: src/[[CLASS]].php
