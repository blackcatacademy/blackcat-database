Tables:
  payment_gateway_notifications:
    Crypto:
      id: passthrough
      transaction_id: passthrough
      tenant_id: passthrough
      received_at: passthrough
      version: passthrough
      processing_by: passthrough
      processing_until: passthrough
      attempts: passthrough
      last_error: passthrough
      status: passthrough
    DefaultOrder: received_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS payment_gateway_notifications (
        id BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        transaction_id VARCHAR(255) NOT NULL,
        tenant_id BIGINT NOT NULL,
        received_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        version INTEGER NOT NULL DEFAULT 0,
        CONSTRAINT chk_pg_notify_version CHECK (version >= 0),
        processing_by VARCHAR(100) NULL,
        processing_until TIMESTAMPTZ(6) NULL,
        attempts INTEGER NOT NULL DEFAULT 0,
        last_error VARCHAR(255) NULL,
        status TEXT NOT NULL DEFAULT 'pending',
        CONSTRAINT chk_pg_notify_status CHECK (status IN ('pending','processing','done','failed')),
        CONSTRAINT chk_pg_notify_attempts CHECK (attempts >= 0)
      );
    foreign_keys:
      - ALTER TABLE payment_gateway_notifications ADD CONSTRAINT fk_pg_notify_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE RESTRICT
      - ALTER TABLE payment_gateway_notifications ADD CONSTRAINT fk_pg_notify_payment FOREIGN KEY (tenant_id, transaction_id) REFERENCES payments(tenant_id, transaction_id) ON DELETE CASCADE
    indexes:
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_pg_notify_tenant_tx ON payment_gateway_notifications (tenant_id, transaction_id)
      - CREATE INDEX IF NOT EXISTS idx_pg_notify_status_received ON payment_gateway_notifications (status, received_at)
      - CREATE INDEX IF NOT EXISTS idx_pg_notify_tenant_status_received ON payment_gateway_notifications (tenant_id, status, received_at)
    Upsert:
      Update:
        - received_at
        - processing_by
        - processing_until
        - attempts
        - last_error
        - status
      Keys:
        - tenant_id
        - transaction_id
  schema_registry:
    Crypto:
      id: passthrough
      system_name: passthrough
      component: passthrough
      version: passthrough
      checksum: passthrough
      applied_at: passthrough
      meta: passthrough
    DefaultOrder: applied_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS schema_registry (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        system_name VARCHAR(120) NOT NULL,
        component   VARCHAR(120) NOT NULL,           -- 'db','rbac','api',...
        version     VARCHAR(64) NOT NULL,
        checksum    VARCHAR(64) NULL,
        applied_at  TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        meta JSONB NULL,
        CONSTRAINT uq_schema_version UNIQUE (system_name, component, version)
      );
    foreign_keys:
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_schema_component ON schema_registry (system_name, component)
    Upsert:
      Update:
        - checksum
        - applied_at
        - meta
      Keys:
        - system_name
        - component
        - version
  api_keys:
    Crypto:
      id: passthrough
      tenant_id: passthrough
      user_id: passthrough
      name: passthrough
      name_ci: passthrough
      token_hash:
        strategy: hmac
        context: db.hmac.api_keys.token_hash
        write_key_version: true
        key_version_column: token_hash_key_version
      token_hash_key_version: passthrough
      scopes: passthrough
      status: passthrough
      last_used_at: passthrough
      expires_at: passthrough
      created_at: passthrough
      updated_at: passthrough
    UpdatedAt: updated_at
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS api_keys (
        id               BIGSERIAL PRIMARY KEY,
        tenant_id        BIGINT NOT NULL,
        user_id          BIGINT NULL,
        name             VARCHAR(120) NOT NULL,
        name_ci          TEXT GENERATED ALWAYS AS (lower(name)) STORED,
        token_hash       BYTEA NOT NULL,
        token_hash_key_version VARCHAR(64) NOT NULL,
        scopes           JSONB NOT NULL DEFAULT '[]'::jsonb,
        status           VARCHAR(20) NOT NULL DEFAULT 'active',
        last_used_at     TIMESTAMPTZ(6) NULL,
        expires_at       TIMESTAMPTZ(6) NULL,
        created_at       TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at       TIMESTAMPTZ(6) NULL,
        CONSTRAINT chk_api_keys_status CHECK (status IN ('active','revoked','disabled'))
      );
    foreign_keys:
      - ALTER TABLE api_keys ADD CONSTRAINT fk_api_keys_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE RESTRICT
      - ALTER TABLE api_keys ADD CONSTRAINT fk_api_keys_user   FOREIGN KEY (user_id)   REFERENCES users(id)   ON DELETE SET NULL
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_api_keys_tenant ON api_keys (tenant_id)
      - CREATE INDEX IF NOT EXISTS idx_api_keys_user   ON api_keys (user_id)
      - CREATE UNIQUE INDEX IF NOT EXISTS uq_api_keys_token ON api_keys (token_hash)
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_api_keys_tenant_name ON api_keys (tenant_id, name_ci)
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_api_keys_tenant_id ON api_keys (tenant_id, id)
  users:
    Crypto:
      id: passthrough
      email_hash:
        strategy: hmac
        context: db.hmac.users.email_hash
        write_key_version: true
        key_version_column: email_hash_key_version
      email_hash_key_version: passthrough
      password_hash: passthrough
      password_algo: passthrough
      password_key_version: passthrough
      is_active: passthrough
      is_locked: passthrough
      failed_logins: passthrough
      must_change_password: passthrough
      last_login_at: passthrough
      last_login_ip_hash:
        strategy: hmac
        context: db.hmac.users.last_login_ip_hash
        write_key_version: true
        key_version_column: last_login_ip_key_version
      last_login_ip_key_version: passthrough
      created_at: passthrough
      updated_at: passthrough
      version: passthrough
      deleted_at: passthrough
      actor_role: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS users (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        email_hash BYTEA NULL,
        email_hash_key_version VARCHAR(64) NULL,
        password_hash VARCHAR(255) NOT NULL,
        password_algo VARCHAR(64) NULL,
        password_key_version VARCHAR(64) NULL,
        is_active BOOLEAN NOT NULL DEFAULT FALSE,
        is_locked  BOOLEAN NOT NULL DEFAULT FALSE,
        failed_logins INTEGER NOT NULL DEFAULT 0,
        must_change_password BOOLEAN NOT NULL DEFAULT FALSE,
        last_login_at TIMESTAMPTZ(6) NULL,
        last_login_ip_hash BYTEA NULL,
        last_login_ip_key_version VARCHAR(64) NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        version INTEGER NOT NULL DEFAULT 0,
        CONSTRAINT chk_users_version CHECK (version >= 0),
        deleted_at TIMESTAMPTZ(6) NULL,
        actor_role TEXT NOT NULL DEFAULT 'customer',
        CONSTRAINT chk_users_actor_role CHECK (actor_role IN ('customer','admin'))
      );
    UpdatedAt: updated_at
    DefaultOrder: id DESC
    Upsert:
      Update:
        - email_hash_key_version
        - password_hash
        - password_algo
        - password_key_version
        - is_active
        - is_locked
        - failed_logins
        - must_change_password
        - last_login_at
        - last_login_ip_hash
        - last_login_ip_key_version
        - actor_role
        - deleted_at
      Keys:
        - email_hash
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_users_last_login_at ON users (last_login_at)
      - CREATE INDEX IF NOT EXISTS idx_users_is_active ON users (is_active)
      - CREATE INDEX IF NOT EXISTS idx_users_actor_role ON users (actor_role)
      - CREATE INDEX IF NOT EXISTS idx_users_last_login_ip_hash ON users (last_login_ip_hash)
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_users_email_hash ON users (email_hash)
    SoftDelete: deleted_at
    foreign_keys:
  sync_errors:
    Crypto:
      id: passthrough
      source: passthrough
      event_key: passthrough
      peer_id: passthrough
      error: passthrough
      created_at: passthrough
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS sync_errors (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        source VARCHAR(100) NOT NULL,
        event_key CHAR(36) NULL,
        peer_id BIGINT NULL,
        error TEXT NOT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6)
      );
    foreign_keys:
      - ALTER TABLE sync_errors ADD CONSTRAINT fk_sync_err_peer FOREIGN KEY (peer_id) REFERENCES peer_nodes(id) ON DELETE SET NULL
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_sync_errors_peer ON sync_errors (peer_id)
      - CREATE INDEX IF NOT EXISTS idx_sync_errors_created ON sync_errors (created_at)
  encrypted_fields:
    Crypto:
      id: passthrough
      entity_table: passthrough
      entity_pk: passthrough
      field_name: passthrough
      ciphertext: passthrough
      meta: passthrough
      created_at: passthrough
      updated_at: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS encrypted_fields (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        entity_table VARCHAR(64) NOT NULL,
        entity_pk VARCHAR(64) NOT NULL,
        field_name VARCHAR(64) NOT NULL,
        ciphertext BYTEA NOT NULL,
        meta JSONB NOT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT ux_enc_entity_field UNIQUE (entity_table, entity_pk, field_name)
      );
    UpdatedAt: updated_at
    DefaultOrder: id DESC
    Upsert:
      Update:
        - ciphertext
        - meta
        - updated_at
      Keys:
        - entity_table
        - entity_pk
        - field_name
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_enc_entity ON encrypted_fields (entity_table, entity_pk)
      - CREATE INDEX IF NOT EXISTS idx_encrypted_fields_field ON encrypted_fields (field_name)
      - CREATE INDEX IF NOT EXISTS gin_encrypted_fields_meta ON encrypted_fields USING GIN (meta jsonb_path_ops)
    foreign_keys:
  merkle_anchors:
    Crypto:
      id: passthrough
      merkle_root_id: passthrough
      anchor_type: passthrough
      anchor_ref: passthrough
      anchored_at: passthrough
      meta: passthrough
    DefaultOrder: anchored_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS merkle_anchors (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        merkle_root_id BIGINT NOT NULL,
        anchor_type TEXT NOT NULL,                   -- 'file','blockchain','notary'
        anchor_ref  VARCHAR(512) NOT NULL,
        anchored_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        meta JSONB NULL,
        CONSTRAINT chk_anchor_type CHECK (anchor_type IN ('file','blockchain','notary')),
        CONSTRAINT uq_merkle_anchor_ref UNIQUE (anchor_ref, anchor_type, merkle_root_id)
      );
    foreign_keys:
      - ALTER TABLE merkle_anchors ADD CONSTRAINT fk_merkle_anchor_root FOREIGN KEY (merkle_root_id) REFERENCES merkle_roots(id) ON DELETE CASCADE
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_merkle_anchors_mrid ON merkle_anchors (merkle_root_id)
    Upsert:
      Update:
        - anchored_at
        - meta
      Keys:
        - anchor_ref
        - anchor_type
        - merkle_root_id
  user_identities:
    Crypto:
      id: passthrough
      user_id: passthrough
      provider: passthrough
      provider_user_id: passthrough
      created_at: passthrough
      updated_at: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS user_identities (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        user_id BIGINT NOT NULL,
        provider VARCHAR(100) NOT NULL,
        provider_user_id VARCHAR(255) NOT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6)
      );
    UpdatedAt: updated_at
    DefaultOrder: id DESC
    Upsert:
      Update:
        - user_id
      Keys:
        - provider
        - provider_user_id
    indexes:
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_provider_user ON user_identities (provider, provider_user_id)
      - CREATE INDEX IF NOT EXISTS idx_user_identities_user ON user_identities (user_id)
    foreign_keys:
      - ALTER TABLE user_identities ADD CONSTRAINT fk_user_identities_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
  tenant_domains:
    Crypto:
      id: passthrough
      tenant_id: passthrough
      domain: passthrough
      domain_ci: passthrough
      is_primary: passthrough
      created_at: passthrough
    DefaultOrder: id DESC
    create: |-
      CREATE TABLE IF NOT EXISTS tenant_domains (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        tenant_id BIGINT NOT NULL,
        domain VARCHAR(255) NOT NULL,
        domain_ci TEXT GENERATED ALWAYS AS (lower(domain)) STORED,
        is_primary BOOLEAN NOT NULL DEFAULT FALSE,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT uq_tenant_domains UNIQUE (tenant_id, domain_ci)
      );
    foreign_keys:
      - ALTER TABLE tenant_domains ADD CONSTRAINT fk_tenant_domains_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE CASCADE
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_tenant_domains_tenant ON tenant_domains (tenant_id)
  replication_lag_samples:
    Crypto:
      id: passthrough
      peer_id: passthrough
      metric: passthrough
      value: passthrough
      captured_at: passthrough
    DefaultOrder: captured_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS replication_lag_samples (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        peer_id BIGINT NOT NULL,
        metric TEXT NOT NULL,                         -- 'apply_lag_ms','transport_lag_ms'
        value BIGINT NOT NULL,
        captured_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT chk_lag_metric CHECK (metric IN ('apply_lag_ms','transport_lag_ms'))
      );
    foreign_keys:
      - ALTER TABLE replication_lag_samples ADD CONSTRAINT fk_lag_peer FOREIGN KEY (peer_id) REFERENCES peer_nodes(id) ON DELETE CASCADE
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_lag_peer_time ON replication_lag_samples (peer_id, captured_at)
  signing_keys:
    Crypto:
      id: passthrough
      algo_id: passthrough
      name: passthrough
      public_key: passthrough
      private_key_enc:
        strategy: encrypt
        context: db.vault.signing_keys.private_key_enc
      private_key_enc_key_version: passthrough
      kms_key_id: passthrough
      origin: passthrough
      status: passthrough
      scope: passthrough
      created_by: passthrough
      created_at: passthrough
      activated_at: passthrough
      retired_at: passthrough
      notes: passthrough
    DefaultOrder: id DESC
    create: |-
      CREATE TABLE IF NOT EXISTS signing_keys (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        algo_id BIGINT NOT NULL,                   -- crypto_algorithms (class='sig')
        name VARCHAR(120) NOT NULL,
        public_key BYTEA NOT NULL,
        private_key_enc BYTEA NULL,                -- when stored encrypted locally
        private_key_enc_key_version VARCHAR(64) NULL,
        kms_key_id BIGINT NULL,                    -- when stored in KMS/HSM
        origin TEXT NOT NULL DEFAULT 'local',      -- 'local' | 'kms' | 'imported'
        status TEXT NOT NULL DEFAULT 'active',     -- 'active' | 'retired' | 'compromised'
        scope VARCHAR(120) NULL,                   -- e.g. 'audit', 'events', 'assets'
        created_by BIGINT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        activated_at TIMESTAMPTZ(6) NULL,
        retired_at   TIMESTAMPTZ(6) NULL,
        notes TEXT NULL,
        CONSTRAINT uq_signing_keys_name UNIQUE (name),
        CONSTRAINT chk_sk_origin CHECK (origin IN ('local','kms','imported')),
        CONSTRAINT chk_sk_status CHECK (status IN ('active','retired','compromised'))
      );
    foreign_keys:
      - ALTER TABLE signing_keys ADD CONSTRAINT fk_sk_algo  FOREIGN KEY (algo_id)  REFERENCES crypto_algorithms(id) ON DELETE RESTRICT
      - ALTER TABLE signing_keys ADD CONSTRAINT fk_sk_kms   FOREIGN KEY (kms_key_id) REFERENCES kms_keys(id) ON DELETE SET NULL
      - ALTER TABLE signing_keys ADD CONSTRAINT fk_sk_user  FOREIGN KEY (created_by) REFERENCES users(id) ON DELETE SET NULL
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_sk_algo_status ON signing_keys (algo_id, status)
    Upsert:
      Update:
        - algo_id
        - public_key
        - private_key_enc
        - private_key_enc_key_version
        - kms_key_id
        - origin
        - status
        - scope
        - activated_at
        - retired_at
        - notes
      Keys:
        - name
  privacy_requests:
    Crypto:
      id: passthrough
      user_id: passthrough
      type: passthrough
      status: passthrough
      requested_at: passthrough
      processed_at: passthrough
      meta: passthrough
    DefaultOrder: requested_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS privacy_requests (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        user_id BIGINT NULL,
        "type" TEXT NOT NULL,                         -- 'access','erasure','rectify','restrict','portability'
        status TEXT NOT NULL DEFAULT 'pending',
        requested_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        processed_at TIMESTAMPTZ(6) NULL,
        meta JSONB NULL,
        CONSTRAINT chk_pr_type CHECK ("type" IN ('access','erasure','rectify','restrict','portability')),
        CONSTRAINT chk_pr_status CHECK (status IN ('pending','processing','done','failed','cancelled'))
      );
    foreign_keys:
      - ALTER TABLE privacy_requests ADD CONSTRAINT fk_privacy_requests_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_privacy_requests_user ON privacy_requests (user_id)
      - CREATE INDEX IF NOT EXISTS idx_privacy_requests_type_status ON privacy_requests (type, status)
    Upsert:
      Update:
        - status
        - processed_at
        - meta
      Keys:
        - id
  rbac_user_roles:
    Crypto:
      id: passthrough
      user_id: passthrough
      role_id: passthrough
      tenant_id: passthrough
      scope: passthrough
      status: passthrough
      granted_by: passthrough
      granted_at: passthrough
      expires_at: passthrough
    DefaultOrder: granted_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS rbac_user_roles (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        user_id BIGINT NOT NULL,
        role_id BIGINT NOT NULL,
        tenant_id BIGINT NULL,                          -- optional multitenant scope
        scope VARCHAR(120) NULL,                        -- e.g. 'project:123'
        status TEXT NOT NULL DEFAULT 'active',          -- 'active','revoked','expired'
        granted_by BIGINT NULL,
        granted_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        expires_at TIMESTAMPTZ(6) NULL,
        CONSTRAINT uq_rbac_user_roles UNIQUE (user_id, role_id, tenant_id, scope),
        CONSTRAINT chk_rbac_user_roles_status CHECK (status IN ('active','revoked','expired'))
      );
    foreign_keys:
      - ALTER TABLE rbac_user_roles ADD CONSTRAINT fk_rbac_ur_user   FOREIGN KEY (user_id)  REFERENCES users(id) ON DELETE CASCADE
      - ALTER TABLE rbac_user_roles ADD CONSTRAINT fk_rbac_ur_role   FOREIGN KEY (role_id)  REFERENCES rbac_roles(id) ON DELETE CASCADE
      - ALTER TABLE rbac_user_roles ADD CONSTRAINT fk_rbac_ur_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE CASCADE
      - ALTER TABLE rbac_user_roles ADD CONSTRAINT fk_rbac_ur_grant  FOREIGN KEY (granted_by) REFERENCES users(id) ON DELETE SET NULL
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_rbac_user_roles_user ON rbac_user_roles (user_id)
      - CREATE INDEX IF NOT EXISTS idx_rbac_user_roles_role ON rbac_user_roles (role_id)
      - CREATE INDEX IF NOT EXISTS idx_rbac_user_roles_tenant ON rbac_user_roles (tenant_id)
    Upsert:
      Update:
        - status
        - granted_by
        - granted_at
        - expires_at
      Keys:
        - user_id
        - role_id
        - tenant_id
        - scope
  kms_keys:
    Crypto:
      id: passthrough
      provider_id: passthrough
      external_key_ref: passthrough
      purpose: passthrough
      algorithm: passthrough
      status: passthrough
      created_at: passthrough
    DefaultOrder: id DESC
    create: |-
      CREATE TABLE IF NOT EXISTS kms_keys (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        provider_id BIGINT NOT NULL,
        external_key_ref VARCHAR(512) NOT NULL,
        purpose TEXT NOT NULL DEFAULT 'wrap',
        algorithm VARCHAR(64) NULL,
        status TEXT NOT NULL DEFAULT 'active',
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT chk_kms_purpose CHECK (purpose IN ('wrap','encrypt','both')),
        CONSTRAINT chk_kms_status  CHECK (status  IN ('active','retired','disabled'))
      );
    foreign_keys:
      - ALTER TABLE kms_keys ADD CONSTRAINT fk_kms_keys_provider FOREIGN KEY (provider_id) REFERENCES kms_providers(id) ON DELETE CASCADE
    indexes:
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_kms_keys_provider_ref ON kms_keys (provider_id, external_key_ref)
    Upsert:
      Update:
        - purpose
        - algorithm
        - status
      Keys:
        - provider_id
        - external_key_ref
  audit_chain:
    Crypto:
      id: passthrough
      audit_id: passthrough
      chain_name: passthrough
      prev_hash: passthrough
      hash: passthrough
      created_at: passthrough
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS audit_chain (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        audit_id BIGINT NOT NULL,
        chain_name VARCHAR(100) NOT NULL DEFAULT 'default',
        prev_hash BYTEA NULL,
        hash BYTEA NOT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT uq_audit_chain UNIQUE (audit_id)
      );
    foreign_keys:
      - ALTER TABLE audit_chain ADD CONSTRAINT fk_audit_chain_audit FOREIGN KEY (audit_id) REFERENCES audit_log(id) ON DELETE CASCADE
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_audit_chain_name_time ON audit_chain (chain_name, created_at)
    Upsert:
      Update:
        - chain_name
        - prev_hash
        - hash
      Keys:
        - audit_id
  crypto_keys:
    Crypto:
      id: passthrough
      basename: passthrough
      version: passthrough
      filename: passthrough
      file_path: passthrough
      fingerprint: passthrough
      key_meta: passthrough
      key_type: passthrough
      algorithm: passthrough
      length_bits: passthrough
      origin: passthrough
      usage: passthrough
      scope: passthrough
      status: passthrough
      is_backup_encrypted: passthrough
      backup_blob: passthrough
      created_by: passthrough
      created_at: passthrough
      activated_at: passthrough
      retired_at: passthrough
      replaced_by: passthrough
      notes: passthrough
    DefaultOrder: id DESC
    create: |-
      CREATE TABLE IF NOT EXISTS crypto_keys (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        basename VARCHAR(100) NOT NULL,
        version INTEGER NOT NULL,
        filename VARCHAR(255) NULL,
        file_path VARCHAR(1024) NULL,
        fingerprint CHAR(64) NULL,
        key_meta JSONB NULL,
        key_type TEXT NULL,
        algorithm VARCHAR(64) NULL,
        length_bits SMALLINT NULL,
        origin TEXT NULL,
        "usage" TEXT[] NULL,
        scope VARCHAR(100) NULL,
        status TEXT NOT NULL DEFAULT 'active',
        is_backup_encrypted BOOLEAN NOT NULL DEFAULT FALSE,
        backup_blob BYTEA NULL,
        created_by BIGINT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        activated_at TIMESTAMPTZ(6) NULL,
        retired_at TIMESTAMPTZ(6) NULL,
        replaced_by BIGINT NULL,
        notes TEXT NULL,
        CONSTRAINT uq_keys_basename_version UNIQUE (basename, version),
        CONSTRAINT chk_keys_type    CHECK (key_type IS NULL OR key_type IN ('dek','kek','hmac','pepper')),
        CONSTRAINT chk_keys_origin  CHECK (origin IS NULL OR origin IN ('local','kms','imported')),
        CONSTRAINT chk_keys_status  CHECK (status IN ('active','retired','compromised','archived')),
        CONSTRAINT chk_keys_usage   CHECK ("usage" IS NULL OR "usage" <@ ARRAY['encrypt','decrypt','sign','verify','wrap','unwrap'])
      );
    foreign_keys:
      - ALTER TABLE crypto_keys ADD CONSTRAINT fk_keys_created_by FOREIGN KEY (created_by) REFERENCES users(id) ON DELETE SET NULL
      - ALTER TABLE crypto_keys ADD CONSTRAINT fk_keys_replaced_by FOREIGN KEY (replaced_by) REFERENCES crypto_keys(id) ON DELETE SET NULL
    indexes:
    Upsert:
      Update:
        - filename
        - file_path
        - fingerprint
        - key_meta
        - key_type
        - algorithm
        - length_bits
        - origin
        - usage
        - scope
        - status
        - is_backup_encrypted
        - backup_blob
        - created_by
        - activated_at
        - retired_at
        - replaced_by
        - notes
      Keys:
        - basename
        - version
  event_outbox:
    Crypto:
      id: passthrough
      event_key: passthrough
      entity_table: passthrough
      entity_pk: passthrough
      event_type: passthrough
      payload: passthrough
      status: passthrough
      attempts: passthrough
      next_attempt_at: passthrough
      processed_at: passthrough
      producer_node: passthrough
      created_at: passthrough
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS event_outbox (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        event_key CHAR(36) NOT NULL,
        entity_table VARCHAR(64) NOT NULL,
        entity_pk VARCHAR(64) NOT NULL,
        event_type VARCHAR(100) NOT NULL,
        payload JSONB NOT NULL,
        status TEXT NOT NULL DEFAULT 'pending',
        attempts INTEGER NOT NULL DEFAULT 0,
        next_attempt_at TIMESTAMPTZ(6) NULL,
        processed_at TIMESTAMPTZ(6) NULL,
        producer_node VARCHAR(100) NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT uq_event_outbox_key UNIQUE (event_key),
        CONSTRAINT chk_event_outbox_status CHECK (status IN ('pending','sent','failed'))
      );
    foreign_keys:
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_event_outbox_status_sched ON event_outbox (status, next_attempt_at)
      - CREATE INDEX IF NOT EXISTS idx_event_outbox_entity_time ON event_outbox (entity_table, entity_pk, created_at)
      - CREATE INDEX IF NOT EXISTS idx_event_outbox_created_at ON event_outbox (created_at)
      - CREATE INDEX IF NOT EXISTS gin_event_outbox_payload ON event_outbox USING GIN (payload jsonb_path_ops)
    Upsert:
      Update:
        - payload
        - status
        - attempts
        - next_attempt_at
        - processed_at
        - producer_node
      Keys:
        - event_key
  notifications:
    Crypto:
      id: passthrough
      tenant_id: passthrough
      user_id: passthrough
      channel: passthrough
      template: passthrough
      payload: passthrough
      status: passthrough
      retries: passthrough
      max_retries: passthrough
      next_attempt_at: passthrough
      scheduled_at: passthrough
      sent_at: passthrough
      error: passthrough
      last_attempt_at: passthrough
      locked_until: passthrough
      locked_by: passthrough
      priority: passthrough
      created_at: passthrough
      updated_at: passthrough
      version: passthrough
    UpdatedAt: updated_at
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS notifications (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        tenant_id BIGINT NOT NULL,
        user_id BIGINT NULL,
        channel TEXT NOT NULL,
        template VARCHAR(100) NOT NULL,
        payload JSONB NULL,
        status TEXT NOT NULL DEFAULT 'pending',
        retries INTEGER NOT NULL DEFAULT 0,
        max_retries INTEGER NOT NULL DEFAULT 6,
        next_attempt_at TIMESTAMPTZ(6) NULL,
        scheduled_at TIMESTAMPTZ(6) NULL,
        sent_at TIMESTAMPTZ(6) NULL,
        error TEXT NULL,
        last_attempt_at TIMESTAMPTZ(6) NULL,
        locked_until TIMESTAMPTZ(6) NULL,
        locked_by VARCHAR(100) NULL,
        priority INTEGER NOT NULL DEFAULT 0,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        version INTEGER NOT NULL DEFAULT 0,
        CONSTRAINT chk_notifications_version CHECK (version >= 0),
        CONSTRAINT chk_notifications_channel CHECK (channel IN ('email','push')),
        CONSTRAINT chk_notifications_status CHECK (status IN ('pending','processing','sent','failed'))
      );
    foreign_keys:
      - ALTER TABLE notifications ADD CONSTRAINT fk_notifications_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
      - ALTER TABLE notifications ADD CONSTRAINT chk_notifications_retries CHECK (retries >= 0 AND max_retries >= 0)
      - ALTER TABLE notifications ADD CONSTRAINT fk_notifications_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE RESTRICT
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_notifications_status_scheduled ON notifications (status, scheduled_at)
      - CREATE INDEX IF NOT EXISTS idx_notifications_next_attempt ON notifications (next_attempt_at)
      - CREATE INDEX IF NOT EXISTS idx_notifications_locked_until_active ON notifications (locked_until) WHERE status IN ('pending','processing')
      - CREATE INDEX IF NOT EXISTS gin_notifications_payload ON notifications USING GIN (payload jsonb_path_ops)
      - CREATE INDEX IF NOT EXISTS idx_notifications_tenant_status_sched ON notifications (tenant_id, status, scheduled_at)
  retention_enforcement_jobs:
    Crypto:
      id: passthrough
      policy_id: passthrough
      scheduled_at: passthrough
      started_at: passthrough
      finished_at: passthrough
      status: passthrough
      processed_count: passthrough
      error: passthrough
      created_at: passthrough
    UpdatedAt: finished_at
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS retention_enforcement_jobs (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        policy_id BIGINT NOT NULL,
        scheduled_at TIMESTAMPTZ(6) NULL,
        started_at   TIMESTAMPTZ(6) NULL,
        finished_at  TIMESTAMPTZ(6) NULL,
        status TEXT NOT NULL DEFAULT 'pending',
        processed_count BIGINT NOT NULL DEFAULT 0,
        error TEXT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT chk_rej_status CHECK (status IN ('pending','running','done','failed','cancelled'))
      );
    foreign_keys:
      - ALTER TABLE retention_enforcement_jobs ADD CONSTRAINT fk_rej_policy FOREIGN KEY (policy_id) REFERENCES data_retention_policies(id) ON DELETE CASCADE
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_rej_status_sched ON retention_enforcement_jobs (status, scheduled_at)
  signatures:
    Crypto:
      id: passthrough
      subject_table: passthrough
      subject_pk: passthrough
      context: passthrough
      algo_id: passthrough
      signing_key_id: passthrough
      signature: passthrough
      payload_hash: passthrough
      hash_algo_id: passthrough
      created_at: passthrough
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS signatures (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        subject_table VARCHAR(64) NOT NULL,
        subject_pk    VARCHAR(64) NOT NULL,
        context       VARCHAR(64) NOT NULL,          -- e.g. 'audit_chain','event_outbox','asset'
        algo_id BIGINT NOT NULL,                     -- crypto_algorithms (class='sig')
        signing_key_id BIGINT NULL,                  -- identifies where the signature originates
        signature BYTEA NOT NULL,
        payload_hash BYTEA NOT NULL,                 -- e.g. SHA3-512 hash of the signed payload
        hash_algo_id BIGINT NOT NULL,                -- crypto_algorithms (class='hash')
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT uq_signatures UNIQUE (subject_table, subject_pk, context, algo_id)
      );
    foreign_keys:
      - ALTER TABLE signatures ADD CONSTRAINT fk_sigs_algo   FOREIGN KEY (algo_id)        REFERENCES crypto_algorithms(id) ON DELETE RESTRICT
      - ALTER TABLE signatures ADD CONSTRAINT fk_sigs_hash   FOREIGN KEY (hash_algo_id)   REFERENCES crypto_algorithms(id) ON DELETE RESTRICT
      - ALTER TABLE signatures ADD CONSTRAINT fk_sigs_skey   FOREIGN KEY (signing_key_id) REFERENCES signing_keys(id) ON DELETE SET NULL
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_sigs_subject ON signatures (subject_table, subject_pk, context, created_at)
  vat_validations:
    Crypto:
      id: passthrough
      vat_id: passthrough
      country_iso2: passthrough
      valid: passthrough
      checked_at: passthrough
      raw: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS vat_validations (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        vat_id VARCHAR(50) NOT NULL,
        country_iso2 CHAR(2) NOT NULL,
        valid BOOLEAN NOT NULL,
        checked_at TIMESTAMPTZ(6) NOT NULL,
        raw JSONB NULL
      );
    foreign_keys:
      - ALTER TABLE vat_validations ADD CONSTRAINT fk_vat_validations_country FOREIGN KEY (country_iso2) REFERENCES countries(iso2) ON DELETE CASCADE
    indexes:
  kms_providers:
    Crypto:
      id: passthrough
      name: passthrough
      provider: passthrough
      location: passthrough
      project_tenant: passthrough
      created_at: passthrough
      is_enabled: passthrough
    DefaultOrder: id DESC
    create: |-
      CREATE TABLE IF NOT EXISTS kms_providers (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name VARCHAR(100) NOT NULL,
        provider TEXT NOT NULL,
        location VARCHAR(100) NULL,
        project_tenant VARCHAR(150) NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        is_enabled BOOLEAN NOT NULL DEFAULT TRUE,
        CONSTRAINT chk_kms_provider CHECK (provider IN ('gcp','aws','azure','vault'))
      );
    foreign_keys:
    indexes:
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_kms_providers_name ON kms_providers (name)
    Upsert:
      Update:
        - provider
        - location
        - project_tenant
        - is_enabled
      Keys:
        - name
  key_rotation_jobs:
    Crypto:
      id: passthrough
      basename: passthrough
      target_version: passthrough
      scheduled_at: passthrough
      started_at: passthrough
      finished_at: passthrough
      status: passthrough
      attempts: passthrough
      executed_by: passthrough
      result: passthrough
      created_at: passthrough
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS key_rotation_jobs (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        basename VARCHAR(100) NOT NULL,
        target_version INTEGER NULL,
        scheduled_at TIMESTAMPTZ(6) NULL,
        started_at TIMESTAMPTZ(6) NULL,
        finished_at TIMESTAMPTZ(6) NULL,
        status TEXT NOT NULL DEFAULT 'pending',
        attempts INTEGER NOT NULL DEFAULT 0,
        executed_by BIGINT NULL,
        result TEXT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT chk_key_rotation_status CHECK (status IN ('pending','running','done','failed','cancelled'))
      );
    foreign_keys:
      - ALTER TABLE key_rotation_jobs ADD CONSTRAINT fk_key_rotation_jobs_user FOREIGN KEY (executed_by) REFERENCES users(id) ON DELETE SET NULL
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_key_rotation_jobs_basename_sched ON key_rotation_jobs (basename, scheduled_at)
  carts:
    Crypto:
      id: passthrough
      tenant_id: passthrough
      user_id: passthrough
      note: passthrough
      created_at: passthrough
      updated_at: passthrough
      version: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS carts (
        id CHAR(36) PRIMARY KEY,
        tenant_id BIGINT NOT NULL,
        user_id BIGINT NULL,
        note VARCHAR(200) NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        version INTEGER NOT NULL DEFAULT 0,
        CONSTRAINT chk_carts_version CHECK (version >= 0)
      );
    UpdatedAt: updated_at
    DefaultOrder: created_at DESC
    Upsert:
      Update:
        - user_id
        - note
        - updated_at
        - version
      Keys:
        - id
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_carts_tenant ON carts (tenant_id)
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_carts_tenant_id ON carts (tenant_id, id)
    foreign_keys:
      - ALTER TABLE carts ADD CONSTRAINT fk_carts_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL
      - ALTER TABLE carts ADD CONSTRAINT fk_carts_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE RESTRICT
  user_profiles:
    Crypto:
      user_id: passthrough
      profile_enc:
        strategy: encrypt
        context: db.vault.user_profiles.profile_enc
        write_key_version: true
        key_version_column: key_version
        write_encryption_meta: true
        encryption_meta_column: encryption_meta
      key_version: passthrough
      encryption_meta: passthrough
      updated_at: passthrough
      version: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS user_profiles (
        user_id BIGINT PRIMARY KEY,
        profile_enc BYTEA NULL,
        key_version VARCHAR(64) NULL,
        encryption_meta JSONB NULL,
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        version INTEGER NOT NULL DEFAULT 0,
        CONSTRAINT chk_user_profiles_version CHECK (version >= 0)
      );
    UpdatedAt: updated_at
    DefaultOrder: user_id DESC
    Upsert:
      Update:
        - profile_enc
        - key_version
        - encryption_meta
      Keys:
        - user_id
    indexes:
    foreign_keys:
      - ALTER TABLE user_profiles ADD CONSTRAINT fk_user_profiles_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
  payments:
    Crypto:
      id: passthrough
      tenant_id: passthrough
      order_id: passthrough
      gateway: passthrough
      transaction_id: passthrough
      provider_event_id: passthrough
      status: passthrough
      amount: passthrough
      currency: passthrough
      details: passthrough
      created_at: passthrough
      updated_at: passthrough
      version: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS payments (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        tenant_id BIGINT NOT NULL,
        order_id BIGINT NULL,
        gateway VARCHAR(100) NOT NULL,
        transaction_id VARCHAR(255) NULL,
        provider_event_id VARCHAR(255) NULL,
        status TEXT NOT NULL,
        amount NUMERIC(12,2) NOT NULL,
        currency CHAR(3) NOT NULL,
        details JSONB NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        version INTEGER NOT NULL DEFAULT 0,
        CONSTRAINT chk_payments_version CHECK (version >= 0),
        CONSTRAINT chk_payments_status CHECK (status IN ('initiated','pending','authorized','paid','cancelled','partially_refunded','refunded','failed')),
        CONSTRAINT chk_payments_currency CHECK (currency ~ '^[A-Z]{3}$')
      );
    UpdatedAt: updated_at
    DefaultOrder: id DESC
    Upsert:
      Update:
        - order_id
        - gateway
        - provider_event_id
        - status
        - amount
        - currency
        - details
      Keys:
        - tenant_id
        - transaction_id
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_payments_order ON payments (order_id)
      - CREATE INDEX IF NOT EXISTS idx_payments_provider_event ON payments (provider_event_id)
      - CREATE INDEX IF NOT EXISTS idx_payments_created_at ON payments (created_at)
      - CREATE INDEX IF NOT EXISTS idx_payments_order_created ON payments (order_id, created_at)
      - CREATE INDEX IF NOT EXISTS gin_payments_details     ON payments      USING GIN (details jsonb_path_ops)
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_payments_tenant_tx ON payments (tenant_id, transaction_id)
      - CREATE INDEX IF NOT EXISTS idx_payments_tenant_order ON payments (tenant_id, order_id)
      - CREATE INDEX IF NOT EXISTS idx_payments_tenant ON payments (tenant_id)
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_payments_tenant_id ON payments (tenant_id, id)
    foreign_keys:
      - ALTER TABLE payments ADD CONSTRAINT fk_payments_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE RESTRICT
      - ALTER TABLE payments ADD CONSTRAINT fk_payments_order FOREIGN KEY (tenant_id, order_id) REFERENCES orders(tenant_id, id) ON DELETE CASCADE
      - ALTER TABLE payments ADD CONSTRAINT chk_payments_amount CHECK (amount >= 0)
  rate_limit_counters:
    Crypto:
      id: passthrough
      subject_type: passthrough
      subject_id: passthrough
      name: passthrough
      window_start: passthrough
      window_size_sec: passthrough
      count: passthrough
      updated_at: passthrough
    UpdatedAt: updated_at
    DefaultOrder: window_start DESC
    create: |-
      CREATE TABLE IF NOT EXISTS rate_limit_counters (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        subject_type TEXT NOT NULL,
        subject_id   VARCHAR(128) NOT NULL,
        name         VARCHAR(120) NOT NULL,
        window_start TIMESTAMPTZ(6) NOT NULL,
        window_size_sec INTEGER NOT NULL,
        "count" INTEGER NOT NULL DEFAULT 0,
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT uq_rlc UNIQUE (subject_type, subject_id, name, window_start, window_size_sec)
      );
    foreign_keys:
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_rlc_window ON rate_limit_counters (name, window_start)
      - CREATE INDEX IF NOT EXISTS idx_rlc_subject ON rate_limit_counters (subject_type, subject_id)
    Upsert:
      Update:
        - count
        - updated_at
      Keys:
        - subject_type
        - subject_id
        - name
        - window_start
        - window_size_sec
  order_item_downloads:
    Crypto:
      id: passthrough
      tenant_id: passthrough
      order_id: passthrough
      book_id: passthrough
      asset_id: passthrough
      download_token_hash:
        strategy: hmac
        context: db.hmac.order_item_downloads.download_token_hash
        write_key_version: true
        key_version_column: token_key_version
      token_key_version: passthrough
      key_version: passthrough
      max_uses: passthrough
      used: passthrough
      is_active: passthrough
      expires_at: passthrough
      last_used_at: passthrough
      ip_hash:
        strategy: hmac
        context: db.hmac.order_item_downloads.ip_hash
        write_key_version: true
        key_version_column: ip_hash_key_version
      ip_hash_key_version: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS order_item_downloads (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        tenant_id BIGINT NOT NULL,
        order_id BIGINT NOT NULL,
        book_id BIGINT NOT NULL,
        asset_id BIGINT NOT NULL,
        download_token_hash BYTEA NULL,
        token_key_version VARCHAR(64) NULL,
        key_version VARCHAR(64) NULL,
        max_uses INTEGER NOT NULL,
        used INTEGER NOT NULL DEFAULT 0,
        is_active BOOLEAN GENERATED ALWAYS AS (used < max_uses) STORED,
        expires_at TIMESTAMPTZ(6) NOT NULL,
        last_used_at TIMESTAMPTZ(6) NULL,
        ip_hash BYTEA NULL,
        ip_hash_key_version VARCHAR(64) NULL
      );
    foreign_keys:
      - ALTER TABLE order_item_downloads ADD CONSTRAINT fk_oid_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE RESTRICT
      - ALTER TABLE order_item_downloads ADD CONSTRAINT fk_oid_order FOREIGN KEY (tenant_id, order_id) REFERENCES orders(tenant_id, id) ON DELETE CASCADE
      - ALTER TABLE order_item_downloads ADD CONSTRAINT fk_oid_book  FOREIGN KEY (tenant_id, book_id)  REFERENCES books(tenant_id, id) ON DELETE CASCADE
      - ALTER TABLE order_item_downloads ADD CONSTRAINT fk_oid_asset FOREIGN KEY (tenant_id, asset_id) REFERENCES book_assets(tenant_id, id) ON DELETE CASCADE
      - ALTER TABLE order_item_downloads ADD CONSTRAINT chk_oid_uses CHECK (max_uses > 0 AND used >= 0 AND used <= max_uses)
    indexes:
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_oid_tenant_triplet ON order_item_downloads (tenant_id, order_id, book_id, asset_id)
      - CREATE INDEX IF NOT EXISTS idx_oid_tenant_expires_active ON order_item_downloads (tenant_id, expires_at, is_active) WHERE used < max_uses
      - CREATE INDEX IF NOT EXISTS idx_oid_download_token_hash ON order_item_downloads (download_token_hash)
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_oid_tenant_id ON order_item_downloads (tenant_id, id)
      - CREATE INDEX IF NOT EXISTS idx_oid_expires_at ON order_item_downloads (expires_at)
      - CREATE INDEX IF NOT EXISTS idx_oid_tenant_order ON order_item_downloads (tenant_id, order_id)
    Upsert:
      Update:
        - download_token_hash
        - token_key_version
        - key_version
        - max_uses
        - used
        - expires_at
        - last_used_at
        - ip_hash
        - ip_hash_key_version
      Keys:
        - tenant_id
        - order_id
        - book_id
        - asset_id
  entity_external_ids:
    Crypto:
      id: passthrough
      entity_table: passthrough
      entity_pk: passthrough
      source: passthrough
      external_id: passthrough
      created_at: passthrough
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS entity_external_ids (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        entity_table VARCHAR(64) NOT NULL,
        entity_pk    VARCHAR(64) NOT NULL,
        source       VARCHAR(100) NOT NULL,            -- e.g. 'rbac-repo','crm'
        external_id  VARCHAR(200) NOT NULL,
        created_at   TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT uq_entity_external_ids UNIQUE (entity_table, entity_pk, source)
      );
    foreign_keys:
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_ext_ids_source ON entity_external_ids (source)
      - CREATE INDEX IF NOT EXISTS idx_ext_ids_external_id ON entity_external_ids (external_id)
    Upsert:
      Update:
        - external_id
      Keys:
        - entity_table
        - entity_pk
        - source
  book_assets:
    Crypto:
      id: passthrough
      tenant_id: passthrough
      book_id: passthrough
      asset_type: passthrough
      filename: passthrough
      mime_type: passthrough
      size_bytes: passthrough
      storage_path: passthrough
      content_hash: passthrough
      download_filename: passthrough
      is_encrypted: passthrough
      encryption_algo: passthrough
      encryption_key_enc:
        strategy: encrypt
        context: db.vault.book_assets.encryption_key_enc
        write_key_version: true
        key_version_column: key_version
        write_encryption_meta: true
        encryption_meta_column: encryption_meta
      encryption_iv: passthrough
      encryption_tag: passthrough
      encryption_aad: passthrough
      encryption_meta: passthrough
      key_version: passthrough
      key_id: passthrough
      created_at: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS book_assets (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        tenant_id BIGINT NOT NULL,
        book_id BIGINT NOT NULL,
        asset_type TEXT NOT NULL,
        filename VARCHAR(255) NOT NULL,
        mime_type VARCHAR(100) NOT NULL,
        size_bytes BIGINT NOT NULL,
        storage_path TEXT NULL,
        content_hash VARCHAR(64) NULL,
        download_filename VARCHAR(255) NULL,
        is_encrypted BOOLEAN NOT NULL DEFAULT FALSE,
        encryption_algo VARCHAR(50) NULL,
        encryption_key_enc BYTEA NULL,
        encryption_iv  BYTEA NULL,
        encryption_tag BYTEA NULL,
        encryption_aad BYTEA NULL,
        encryption_meta JSONB NULL,
        key_version VARCHAR(64) NULL,
        key_id BIGINT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT chk_asset_type CHECK (asset_type IN ('cover','pdf','epub','mobi','sample','extra'))
      );
    foreign_keys:
      - ALTER TABLE book_assets ADD CONSTRAINT fk_book_assets_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE RESTRICT
      - ALTER TABLE book_assets ADD CONSTRAINT fk_book_assets_book FOREIGN KEY (tenant_id, book_id) REFERENCES books(tenant_id, id) ON DELETE CASCADE
      - ALTER TABLE book_assets ADD CONSTRAINT fk_book_assets_key FOREIGN KEY (key_id) REFERENCES crypto_keys(id) ON DELETE SET NULL
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_book_assets_book ON book_assets (book_id)
      - CREATE INDEX IF NOT EXISTS idx_book_assets_type ON book_assets (asset_type)
      - CREATE INDEX IF NOT EXISTS gin_book_assets_enc_meta ON book_assets USING GIN (encryption_meta jsonb_path_ops)
      - CREATE INDEX IF NOT EXISTS idx_book_assets_tenant ON book_assets (tenant_id)
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_book_assets_tenant_unique ON book_assets (tenant_id, book_id, asset_type)
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_book_assets_tenant_id ON book_assets (tenant_id, id)
    Upsert:
      Update:
        - filename
        - mime_type
        - size_bytes
        - storage_path
        - content_hash
        - download_filename
        - is_encrypted
        - encryption_algo
        - encryption_key_enc
        - encryption_iv
        - encryption_tag
        - encryption_aad
        - encryption_meta
        - key_version
        - key_id
      Keys:
        - tenant_id
        - book_id
        - asset_type
  kms_routing_policies:
    Crypto:
      id: passthrough
      name: passthrough
      priority: passthrough
      strategy: passthrough
      match: passthrough
      providers: passthrough
      active: passthrough
      created_at: passthrough
    DefaultOrder: priority DESC
    create: |-
      CREATE TABLE IF NOT EXISTS kms_routing_policies (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name VARCHAR(120) NOT NULL,
        priority INTEGER NOT NULL DEFAULT 0,
        strategy TEXT NOT NULL DEFAULT 'prefer',      -- 'prefer','require','avoid'
        match JSONB NULL,                             -- e.g. {"tenant_id":123,"region":"eu"}
        providers JSONB NOT NULL,                     -- e.g. [{"provider_id":1,"weight":80},...]
        active BOOLEAN NOT NULL DEFAULT TRUE,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT chk_kms_route_strategy CHECK (strategy IN ('prefer','require','avoid'))
      );
    foreign_keys:
    indexes:
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_kms_route_name ON kms_routing_policies (name)
      - CREATE INDEX IF NOT EXISTS idx_kms_route_active ON kms_routing_policies (active, priority DESC)
    Upsert:
      Update:
        - priority
        - strategy
        - match
        - providers
        - active
      Keys:
        - name
  field_hash_policies:
    Crypto:
      id: passthrough
      entity_table: passthrough
      field_name: passthrough
      profile_id: passthrough
      effective_from: passthrough
      notes: passthrough
      created_at: passthrough
      updated_at: passthrough
    DefaultOrder: effective_from DESC
    create: |-
      CREATE TABLE IF NOT EXISTS field_hash_policies (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        entity_table VARCHAR(64) NOT NULL,
        field_name   VARCHAR(64) NOT NULL,
        profile_id   BIGINT NOT NULL,               -- hash_profiles
        effective_from TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        notes TEXT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT uq_fhp UNIQUE (entity_table, field_name, effective_from)
      );
    foreign_keys:
      - ALTER TABLE field_hash_policies ADD CONSTRAINT fk_fhp_profile FOREIGN KEY (profile_id) REFERENCES hash_profiles(id) ON DELETE RESTRICT
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_fhp_entity_field ON field_hash_policies (entity_table, field_name, effective_from)
  rate_limits:
    Crypto:
      id: passthrough
      subject_type: passthrough
      subject_id: passthrough
      name: passthrough
      window_size_sec: passthrough
      limit_count: passthrough
      active: passthrough
      created_at: passthrough
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS rate_limits (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        subject_type TEXT NOT NULL,                   -- 'ip','user','api_key','tenant'
        subject_id   VARCHAR(128) NOT NULL,
        name         VARCHAR(120) NOT NULL,          -- e.g. 'login','api'
        window_size_sec INTEGER NOT NULL,
        limit_count    INTEGER NOT NULL,
        active BOOLEAN NOT NULL DEFAULT TRUE,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT uq_rate_limits UNIQUE (subject_type, subject_id, name, window_size_sec),
        CONSTRAINT chk_rate_window CHECK (window_size_sec > 0),
        CONSTRAINT chk_rate_limit  CHECK (limit_count  > 0)
      );
    foreign_keys:
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_rate_limits_active ON rate_limits (active)
    Upsert:
      Update:
        - limit_count
        - active
      Keys:
        - subject_type
        - subject_id
        - name
        - window_size_sec
  tenants:
    Crypto:
      id: passthrough
      name: passthrough
      slug: passthrough
      slug_ci: passthrough
      status: passthrough
      created_at: passthrough
      updated_at: passthrough
      version: passthrough
      deleted_at: passthrough
      is_live: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS tenants (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name VARCHAR(200) NOT NULL,
        slug VARCHAR(200) NOT NULL,
        slug_ci TEXT GENERATED ALWAYS AS (lower(slug)) STORED,
        status TEXT NOT NULL DEFAULT 'active',              -- 'active','suspended','deleted'
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        version INTEGER NOT NULL DEFAULT 0,
        CONSTRAINT chk_tenants_status CHECK (status IN ('active','suspended','deleted')),
        deleted_at TIMESTAMPTZ(6) NULL,
        is_live BOOLEAN GENERATED ALWAYS AS (deleted_at IS NULL) STORED
      );
    UpdatedAt: updated_at
    DefaultOrder: id DESC
    foreign_keys:
    indexes:
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_tenants_slug_live_ci ON tenants (slug_ci, is_live)
    SoftDelete: deleted_at
  global_id_registry:
    Crypto:
      gid: passthrough
      guid: passthrough
      entity_table: passthrough
      entity_pk: passthrough
      created_at: passthrough
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS global_id_registry (
        gid CHAR(26) PRIMARY KEY,                     -- ULID (portable)
        guid UUID NULL,                               -- optionally also UUID
        entity_table VARCHAR(64) NOT NULL,
        entity_pk    VARCHAR(64) NOT NULL,
        created_at   TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT uq_gid_entity UNIQUE (entity_table, entity_pk)
      );
    foreign_keys:
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_gid_table ON global_id_registry (entity_table)
      - CREATE INDEX IF NOT EXISTS idx_gid_guid ON global_id_registry (guid)
    Upsert:
      Update:
        - guid
        - entity_table
        - entity_pk
      Keys:
        - gid
  books:
    Crypto:
      id: passthrough
      tenant_id: passthrough
      title: passthrough
      slug: passthrough
      slug_ci: passthrough
      short_description: passthrough
      full_description: passthrough
      price: passthrough
      currency: passthrough
      author_id: passthrough
      main_category_id: passthrough
      isbn: passthrough
      language: passthrough
      pages: passthrough
      publisher: passthrough
      published_at: passthrough
      sku: passthrough
      is_active: passthrough
      is_available: passthrough
      stock_quantity: passthrough
      created_at: passthrough
      updated_at: passthrough
      version: passthrough
      deleted_at: passthrough
      is_live: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS books (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        tenant_id BIGINT NOT NULL,
        title VARCHAR(255) NOT NULL,
        slug VARCHAR(255) NOT NULL,
        slug_ci TEXT GENERATED ALWAYS AS (lower(slug)) STORED,
        short_description VARCHAR(512) NULL,
        full_description TEXT NULL,
        price NUMERIC(12,2) NOT NULL DEFAULT 0.00,
        currency CHAR(3) NOT NULL DEFAULT 'EUR',
        author_id BIGINT NOT NULL,
        main_category_id BIGINT NOT NULL,
        isbn VARCHAR(32) NULL,
        language CHAR(5) NULL,
        pages INTEGER NULL,
        publisher VARCHAR(255) NULL,
        published_at DATE NULL,
        sku VARCHAR(64) NULL,
        is_active BOOLEAN NOT NULL DEFAULT TRUE,
        is_available BOOLEAN NOT NULL DEFAULT TRUE,
        stock_quantity INTEGER NOT NULL DEFAULT 0,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        version INTEGER NOT NULL DEFAULT 0,
        CONSTRAINT chk_books_version CHECK (version >= 0),
        deleted_at TIMESTAMPTZ(6) NULL,
        is_live BOOLEAN GENERATED ALWAYS AS (deleted_at IS NULL) STORED,
        CONSTRAINT chk_books_pages      CHECK (pages IS NULL OR pages >= 0),
        CONSTRAINT chk_books_stock_qty  CHECK (stock_quantity >= 0),
        CONSTRAINT chk_books_currency CHECK (currency ~ '^[A-Z]{3}$'),
        CONSTRAINT chk_books_price_nonneg CHECK (price >= 0)
      );
    UpdatedAt: updated_at
    DefaultOrder: id DESC
    Upsert:
      Update:
        - title
        - short_description
        - full_description
        - price
        - currency
        - author_id
        - main_category_id
        - isbn
        - language
        - pages
        - publisher
        - published_at
        - sku
        - is_active
        - is_available
        - stock_quantity
        - deleted_at
      Keys:
        - tenant_id
        - slug_ci
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_books_author_id ON books (author_id)
      - CREATE INDEX IF NOT EXISTS idx_books_main_category_id ON books (main_category_id)
      - CREATE INDEX IF NOT EXISTS idx_books_sku ON books (sku)
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_books_tenant_slug_live_ci ON books (tenant_id, slug_ci, is_live)
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_books_tenant_isbn ON books (tenant_id, isbn)
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_books_tenant_id ON books (tenant_id, id)
      - CREATE INDEX IF NOT EXISTS idx_books_tenant_author ON books (tenant_id, author_id)
      - CREATE INDEX IF NOT EXISTS idx_books_tenant_category ON books (tenant_id, main_category_id)
    SoftDelete: deleted_at
    foreign_keys:
      - ALTER TABLE books ADD CONSTRAINT fk_books_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE RESTRICT
      - ALTER TABLE books ADD CONSTRAINT fk_books_author FOREIGN KEY (tenant_id, author_id) REFERENCES authors(tenant_id, id) ON DELETE RESTRICT
      - ALTER TABLE books ADD CONSTRAINT fk_books_category FOREIGN KEY (tenant_id, main_category_id) REFERENCES categories(tenant_id, id) ON DELETE RESTRICT
  sessions:
    Crypto:
      id: passthrough
      token_hash:
        strategy: hmac
        context: db.hmac.sessions.token_hash
        write_key_version: true
        key_version_column: token_hash_key_version
      token_hash_key_version: passthrough
      token_fingerprint: passthrough
      token_issued_at: passthrough
      user_id: passthrough
      created_at: passthrough
      version: passthrough
      last_seen_at: passthrough
      expires_at: passthrough
      failed_decrypt_count: passthrough
      last_failed_decrypt_at: passthrough
      revoked: passthrough
      ip_hash:
        strategy: hmac
        context: db.hmac.sessions.ip_hash
        write_key_version: true
        key_version_column: ip_hash_key_version
      ip_hash_key_version: passthrough
      user_agent: passthrough
      session_blob: passthrough
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS sessions (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        token_hash BYTEA NOT NULL,
        token_hash_key_version VARCHAR(64) NULL,
        token_fingerprint BYTEA NULL,
        token_issued_at TIMESTAMPTZ(6) NULL,
        user_id BIGINT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        version INTEGER NOT NULL DEFAULT 0,
        CONSTRAINT chk_sessions_version CHECK (version >= 0),
        last_seen_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        expires_at TIMESTAMPTZ(6) NULL,
        failed_decrypt_count INTEGER NOT NULL DEFAULT 0,
        last_failed_decrypt_at TIMESTAMPTZ(6) NULL,
        revoked BOOLEAN NOT NULL DEFAULT FALSE,
        ip_hash BYTEA NULL,
        ip_hash_key_version VARCHAR(64) NULL,
        user_agent VARCHAR(1024) NULL,
        session_blob BYTEA NULL,
        CONSTRAINT uq_sessions_token_hash UNIQUE (token_hash),
        CONSTRAINT chk_sessions_failed_decrypt_count CHECK (failed_decrypt_count >= 0),
        CONSTRAINT chk_sessions_expires_after_created CHECK (expires_at IS NULL OR expires_at >= created_at)
      );
    foreign_keys:
      - ALTER TABLE sessions ADD CONSTRAINT fk_sessions_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_sessions_user_created ON sessions (user_id, created_at)
      - CREATE INDEX IF NOT EXISTS idx_sessions_user ON sessions (user_id)
      - CREATE INDEX IF NOT EXISTS idx_sessions_expires_at ON sessions (expires_at)
      - CREATE INDEX IF NOT EXISTS idx_sessions_last_seen ON sessions (last_seen_at)
      - CREATE INDEX IF NOT EXISTS idx_sessions_token_hash_key ON sessions (token_hash_key_version)
      - CREATE INDEX IF NOT EXISTS idx_sessions_created_at ON sessions (created_at)
      - CREATE INDEX IF NOT EXISTS idx_sessions_active ON sessions (revoked, expires_at, user_id)
      - CREATE INDEX IF NOT EXISTS idx_sessions_user_revoked_seen ON sessions (user_id, revoked, last_seen_at DESC)
    Upsert:
      Update:
        - token_hash_key_version
        - token_fingerprint
        - token_issued_at
        - user_id
        - last_seen_at
        - expires_at
        - failed_decrypt_count
        - last_failed_decrypt_at
        - revoked
        - ip_hash
        - ip_hash_key_version
        - user_agent
        - session_blob
      Keys:
        - token_hash
  key_wrapper_layers:
    Crypto:
      id: passthrough
      key_wrapper_id: passthrough
      layer_no: passthrough
      kms_key_id: passthrough
      kem_algo_id: passthrough
      kem_ciphertext: passthrough
      encap_pubkey: passthrough
      aad: passthrough
      meta: passthrough
      created_at: passthrough
    DefaultOrder: key_wrapper_id DESC, layer_no ASC
    create: |-
      CREATE TABLE IF NOT EXISTS key_wrapper_layers (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        key_wrapper_id BIGINT NOT NULL,
        layer_no SMALLINT NOT NULL,                -- 1..N layer order
        kms_key_id BIGINT NULL,                    -- optional: reference to a KMS key
        kem_algo_id BIGINT NOT NULL,               -- odkaz na crypto_algorithms (class='kem')
        kem_ciphertext BYTEA NOT NULL,             -- encapsulated key (ready for longer PQC ciphertext)
        encap_pubkey BYTEA NULL,                   -- for hybrid/external KEM as needed
        aad JSONB NULL,                            -- AAD used during wrapping
        meta JSONB NULL,                           -- e.g. { "hybrid_with": "x25519" }
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT uq_kwl UNIQUE (key_wrapper_id, layer_no)
      );
    foreign_keys:
      - ALTER TABLE key_wrapper_layers ADD CONSTRAINT fk_kwl_kw   FOREIGN KEY (key_wrapper_id) REFERENCES key_wrappers(id) ON DELETE CASCADE
      - ALTER TABLE key_wrapper_layers ADD CONSTRAINT fk_kwl_kms  FOREIGN KEY (kms_key_id)     REFERENCES kms_keys(id) ON DELETE SET NULL
      - ALTER TABLE key_wrapper_layers ADD CONSTRAINT fk_kwl_algo FOREIGN KEY (kem_algo_id)    REFERENCES crypto_algorithms(id) ON DELETE RESTRICT
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_kwl_kw ON key_wrapper_layers (key_wrapper_id)
      - CREATE INDEX IF NOT EXISTS idx_kwl_algo ON key_wrapper_layers (kem_algo_id)
  order_items:
    Crypto:
      id: passthrough
      tenant_id: passthrough
      order_id: passthrough
      book_id: passthrough
      product_ref: passthrough
      title_snapshot: passthrough
      sku_snapshot: passthrough
      unit_price: passthrough
      quantity: passthrough
      tax_rate: passthrough
      currency: passthrough
      created_at: passthrough
      updated_at: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS order_items (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        tenant_id BIGINT NOT NULL,
        order_id BIGINT NULL,
        book_id BIGINT NULL,
        product_ref INTEGER NULL,
        title_snapshot VARCHAR(255) NOT NULL,
        sku_snapshot VARCHAR(64) NULL,
        unit_price NUMERIC(12,2) NOT NULL,
        quantity INTEGER NOT NULL,
        tax_rate NUMERIC(5,2) NOT NULL,
        currency CHAR(3) NOT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT chk_order_items_qty CHECK (quantity > 0),
        CONSTRAINT chk_order_items_currency CHECK (currency ~ '^[A-Z]{3}$'),
        CONSTRAINT chk_order_items_tax_rate CHECK (tax_rate BETWEEN 0 AND 100),
        CONSTRAINT chk_order_items_nonneg CHECK (unit_price >= 0)
      );
    foreign_keys:
      - ALTER TABLE order_items ADD CONSTRAINT fk_order_items_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE RESTRICT ON UPDATE RESTRICT
      - ALTER TABLE order_items ADD CONSTRAINT fk_order_items_order  FOREIGN KEY (tenant_id, order_id) REFERENCES orders(tenant_id, id) ON DELETE CASCADE ON UPDATE RESTRICT
      - ALTER TABLE order_items ADD CONSTRAINT fk_order_items_book   FOREIGN KEY (tenant_id, book_id) REFERENCES books(tenant_id, id) ON DELETE CASCADE ON UPDATE RESTRICT
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_order_items_order_id ON order_items (order_id)
      - CREATE INDEX IF NOT EXISTS idx_order_items_book_id ON order_items (book_id)
      - CREATE INDEX IF NOT EXISTS idx_order_items_tenant_order ON order_items (tenant_id, order_id)
      - CREATE INDEX IF NOT EXISTS idx_order_items_tenant_book  ON order_items (tenant_id, book_id)
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_order_items_tenant_id ON order_items (tenant_id, id)
  payment_webhooks:
    Crypto:
      id: passthrough
      payment_id: passthrough
      gateway_event_id: passthrough
      payload_hash: passthrough
      payload: passthrough
      from_cache: passthrough
      created_at: passthrough
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS payment_webhooks (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        payment_id BIGINT NULL,
        gateway_event_id VARCHAR(255) NULL,
        payload_hash CHAR(64) NOT NULL,
        payload JSONB NULL,
        from_cache BOOLEAN NOT NULL DEFAULT FALSE,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6)
      );
    foreign_keys:
      - ALTER TABLE payment_webhooks ADD CONSTRAINT fk_payment_webhooks_payment FOREIGN KEY (payment_id) REFERENCES payments(id) ON DELETE SET NULL
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_payment_webhooks_payment ON payment_webhooks (payment_id)
      - CREATE INDEX IF NOT EXISTS idx_payment_webhooks_gw_id ON payment_webhooks (gateway_event_id)
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_payment_webhooks_payload ON payment_webhooks (payload_hash)
  invoices:
    Crypto:
      id: passthrough
      tenant_id: passthrough
      order_id: passthrough
      invoice_number: passthrough
      variable_symbol: passthrough
      issue_date: passthrough
      due_date: passthrough
      subtotal: passthrough
      discount_total: passthrough
      tax_total: passthrough
      total: passthrough
      currency: passthrough
      qr_data: passthrough
      created_at: passthrough
    DefaultOrder: id DESC
    create: |-
      CREATE TABLE IF NOT EXISTS invoices (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        tenant_id BIGINT NOT NULL,
        order_id BIGINT NULL,
        invoice_number VARCHAR(100) NOT NULL,
        variable_symbol VARCHAR(50) NULL,
        issue_date DATE NOT NULL,
        due_date DATE NULL,
        subtotal NUMERIC(12,2) NOT NULL,
        discount_total NUMERIC(12,2) NOT NULL,
        tax_total NUMERIC(12,2) NOT NULL,
        total NUMERIC(12,2) NOT NULL,
        currency CHAR(3) NOT NULL,
        qr_data TEXT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT chk_invoices_currency CHECK (currency ~ '^[A-Z]{3}$')
      );
    foreign_keys:
      - ALTER TABLE invoices ADD CONSTRAINT fk_invoices_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE RESTRICT
      - ALTER TABLE invoices ADD CONSTRAINT fk_invoices_order FOREIGN KEY (tenant_id, order_id) REFERENCES orders(tenant_id, id) ON DELETE RESTRICT
    indexes:
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_invoices_tenant_no ON invoices (tenant_id, invoice_number)
      - CREATE INDEX IF NOT EXISTS idx_invoices_tenant_order ON invoices (tenant_id, order_id)
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_invoices_tenant_id ON invoices (tenant_id, id)
    Upsert:
      Update:
        - order_id
        - variable_symbol
        - issue_date
        - due_date
        - subtotal
        - discount_total
        - tax_total
        - total
        - currency
        - qr_data
      Keys:
        - tenant_id
        - invoice_number
  event_dlq:
    Crypto:
      id: passthrough
      source: passthrough
      event_key: passthrough
      event: passthrough
      error: passthrough
      retryable: passthrough
      attempts: passthrough
      first_failed_at: passthrough
      last_failed_at: passthrough
    DefaultOrder: last_failed_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS event_dlq (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        source VARCHAR(100) NOT NULL,
        event_key CHAR(36) NULL,
        event JSONB NOT NULL,
        error TEXT NOT NULL,
        retryable BOOLEAN NOT NULL DEFAULT FALSE,
        attempts INTEGER NOT NULL DEFAULT 0,
        first_failed_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        last_failed_at  TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6)
      );
    foreign_keys:
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_event_dlq_source_time ON event_dlq (source, last_failed_at)
  event_inbox:
    Crypto:
      id: passthrough
      source: passthrough
      event_key: passthrough
      payload: passthrough
      status: passthrough
      attempts: passthrough
      last_error: passthrough
      received_at: passthrough
      processed_at: passthrough
    DefaultOrder: received_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS event_inbox (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        source VARCHAR(100) NOT NULL,
        event_key CHAR(36) NOT NULL,
        payload JSONB NOT NULL,
        status TEXT NOT NULL DEFAULT 'pending',
        attempts INTEGER NOT NULL DEFAULT 0,
        last_error TEXT NULL,
        received_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        processed_at TIMESTAMPTZ(6) NULL,
        CONSTRAINT uq_event_inbox_key UNIQUE (source, event_key),
        CONSTRAINT chk_event_inbox_status CHECK (status IN ('pending','processed','failed'))
      );
    foreign_keys:
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_event_inbox_status_received ON event_inbox (status, received_at)
      - CREATE INDEX IF NOT EXISTS idx_event_inbox_processed ON event_inbox (processed_at)
      - CREATE INDEX IF NOT EXISTS gin_event_inbox_payload ON event_inbox USING GIN (payload jsonb_path_ops)
    Upsert:
      Update:
        - payload
        - status
        - attempts
        - last_error
        - processed_at
      Keys:
        - source
        - event_key
  cart_items:
    Crypto:
      id: passthrough
      tenant_id: passthrough
      cart_id: passthrough
      book_id: passthrough
      sku: passthrough
      sku_norm: passthrough
      variant: passthrough
      quantity: passthrough
      unit_price: passthrough
      price_snapshot: passthrough
      currency: passthrough
      meta: passthrough
      created_at: passthrough
      updated_at: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS cart_items (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        tenant_id BIGINT NOT NULL,
        cart_id CHAR(36) NOT NULL,
        book_id BIGINT NOT NULL,
        sku VARCHAR(64) NULL,
        sku_norm VARCHAR(64) GENERATED ALWAYS AS (COALESCE(sku, '')) STORED,
        variant JSONB NULL,
        quantity INTEGER NOT NULL,
        unit_price NUMERIC(12,2) NOT NULL DEFAULT 0.00,
        price_snapshot NUMERIC(12,2) NOT NULL,
        currency CHAR(3) NOT NULL,
        meta JSONB NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT chk_cart_currency CHECK (currency ~ '^[A-Z]{3}$'),
        CONSTRAINT chk_cart_qty CHECK (quantity > 0)
      );
    foreign_keys:
      - ALTER TABLE cart_items ADD CONSTRAINT fk_cart_items_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE RESTRICT
      - ALTER TABLE cart_items ADD CONSTRAINT fk_cart_items_cart  FOREIGN KEY (tenant_id, cart_id) REFERENCES carts(tenant_id, id) ON DELETE CASCADE
      - ALTER TABLE cart_items ADD CONSTRAINT fk_cart_items_book  FOREIGN KEY (tenant_id, book_id) REFERENCES books(tenant_id, id) ON DELETE CASCADE
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_cart_items_cart_id ON cart_items (cart_id)
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_cart_items_tenant_norm ON cart_items (tenant_id, cart_id, book_id, sku_norm)
      - CREATE INDEX IF NOT EXISTS idx_cart_items_tenant_cart ON cart_items (tenant_id, cart_id)
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_cart_items ON cart_items (tenant_id, cart_id, book_id, sku)
      - CREATE INDEX IF NOT EXISTS idx_cart_items_tenant_book ON cart_items (tenant_id, book_id)
  user_consents:
    Crypto:
      id: passthrough
      user_id: passthrough
      consent_type: passthrough
      version: passthrough
      granted: passthrough
      granted_at: passthrough
      source: passthrough
      meta: passthrough
    DefaultOrder: id DESC
    create: |-
      CREATE TABLE IF NOT EXISTS user_consents (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        user_id BIGINT NOT NULL,
        consent_type VARCHAR(50) NOT NULL,
        version VARCHAR(50) NOT NULL,
        granted BOOLEAN NOT NULL,
        granted_at TIMESTAMPTZ(6) NOT NULL,
        source VARCHAR(100) NULL,
        meta JSONB NULL
      );
    foreign_keys:
      - ALTER TABLE user_consents ADD CONSTRAINT fk_user_consents_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_user_consents_user ON user_consents (user_id)
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_user_consents ON user_consents (user_id, consent_type, version)
    Upsert:
      Update:
        - granted
        - granted_at
        - source
        - meta
      Keys:
        - user_id
        - consent_type
        - version
  orders:
    Crypto:
      id: passthrough
      tenant_id: passthrough
      uuid: passthrough
      uuid_bin: passthrough
      public_order_no: passthrough
      user_id: passthrough
      status: passthrough
      encrypted_customer_blob:
        strategy: encrypt
        context: db.vault.orders.encrypted_customer_blob
        write_key_version: true
        key_version_column: encrypted_customer_blob_key_version
        write_encryption_meta: true
        encryption_meta_column: encryption_meta
      encrypted_customer_blob_key_version: passthrough
      encryption_meta: passthrough
      currency: passthrough
      metadata: passthrough
      subtotal: passthrough
      discount_total: passthrough
      tax_total: passthrough
      total: passthrough
      payment_method: passthrough
      created_at: passthrough
      updated_at: passthrough
      version: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS orders (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        tenant_id BIGINT NOT NULL,
        uuid CHAR(36) NOT NULL UNIQUE,
        uuid_bin BYTEA NULL,
        public_order_no VARCHAR(64) NULL,
        user_id BIGINT NULL,
        status TEXT NOT NULL DEFAULT 'pending',
        encrypted_customer_blob BYTEA NULL,
        encrypted_customer_blob_key_version VARCHAR(64) NULL,
        encryption_meta JSONB NULL,
        currency CHAR(3) NOT NULL,
        metadata JSONB NULL,
        subtotal NUMERIC(12,2) NOT NULL DEFAULT 0,
        discount_total NUMERIC(12,2) NOT NULL DEFAULT 0,
        tax_total NUMERIC(12,2) NOT NULL DEFAULT 0,
        total NUMERIC(12,2) NOT NULL DEFAULT 0,
        payment_method VARCHAR(100) NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        version INTEGER NOT NULL DEFAULT 0,
        CONSTRAINT chk_orders_version CHECK (version >= 0),
        CONSTRAINT chk_orders_status CHECK (status IN ('pending','paid','failed','cancelled','refunded','completed')),
        CONSTRAINT chk_orders_currency CHECK (currency ~ '^[A-Z]{3}$'),
        CONSTRAINT chk_orders_nonneg CHECK (subtotal >= 0 AND discount_total >= 0 AND tax_total >= 0 AND total >= 0),
        CONSTRAINT chk_orders_total_eq CHECK (total = subtotal - discount_total + tax_total)
      );
    UpdatedAt: updated_at
    DefaultOrder: id DESC
    Upsert:
      Update:
        - uuid_bin
        - public_order_no
        - user_id
        - status
        - encrypted_customer_blob
        - encrypted_customer_blob_key_version
        - encryption_meta
        - currency
        - metadata
        - subtotal
        - discount_total
        - tax_total
        - total
        - payment_method
      Keys:
        - uuid
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_orders_user_id ON orders (user_id)
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_orders_uuid_bin ON orders (uuid_bin)
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_orders_tenant_public_no ON orders (tenant_id, public_order_no)
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_orders_tenant_id ON orders (tenant_id, id)
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_orders_tenant_uuid_bin ON orders (tenant_id, uuid_bin)
      - CREATE INDEX IF NOT EXISTS idx_orders_status ON orders (status)
      - CREATE INDEX IF NOT EXISTS idx_orders_user_status ON orders (user_id, status)
      - CREATE INDEX IF NOT EXISTS idx_orders_created_at ON orders (created_at)
      - CREATE INDEX IF NOT EXISTS idx_orders_user_created ON orders (user_id, created_at)
      - CREATE INDEX IF NOT EXISTS gin_orders_metadata      ON orders USING GIN (metadata jsonb_path_ops)
      - CREATE INDEX IF NOT EXISTS idx_orders_tenant ON orders (tenant_id)
      - CREATE INDEX IF NOT EXISTS idx_orders_tenant_user ON orders (tenant_id, user_id)
      - CREATE INDEX IF NOT EXISTS idx_orders_tenant_user_created ON orders (tenant_id, user_id, created_at)
    foreign_keys:
      - ALTER TABLE orders ADD CONSTRAINT fk_orders_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL
      - ALTER TABLE orders ADD CONSTRAINT fk_orders_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE RESTRICT
  login_attempts:
    Crypto:
      id: passthrough
      ip_hash:
        strategy: hmac
        context: db.hmac.login_attempts.ip_hash
      ip_hash_key_version: passthrough
      attempted_at: passthrough
      success: passthrough
      user_id: passthrough
      username_hash:
        strategy: hmac
        context: db.hmac.login_attempts.username_hash
      username_hash_key_version: passthrough
      auth_event_id: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS login_attempts (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY,
        ip_hash BYTEA NOT NULL,
        ip_hash_key_version VARCHAR(64) NULL,
        attempted_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        success BOOLEAN NOT NULL DEFAULT FALSE,
        user_id BIGINT NULL,
        username_hash BYTEA NULL,
        username_hash_key_version VARCHAR(64) NULL,
        auth_event_id BIGINT NULL,
        CONSTRAINT chk_login_success CHECK (success IN (FALSE, TRUE))
      );
    foreign_keys:
      - ALTER TABLE login_attempts ADD CONSTRAINT fk_login_attempts_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL
      - ALTER TABLE login_attempts ADD CONSTRAINT fk_login_attempts_auth_event FOREIGN KEY (auth_event_id) REFERENCES auth_events(id) ON DELETE SET NULL
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_login_ip_success_time ON login_attempts (ip_hash, success, attempted_at)
      - CREATE INDEX IF NOT EXISTS idx_login_attempted_at ON login_attempts (attempted_at)
      - CREATE INDEX IF NOT EXISTS idx_login_username_hash ON login_attempts (username_hash)
      - CREATE INDEX IF NOT EXISTS idx_login_auth_event ON login_attempts (auth_event_id)
      - CREATE INDEX IF NOT EXISTS idx_login_user_time ON login_attempts (user_id, attempted_at)
  encryption_events:
    Crypto:
      id: passthrough
      entity_table: passthrough
      entity_pk: passthrough
      field_name: passthrough
      op: passthrough
      policy_id: passthrough
      local_key_version: passthrough
      layers: passthrough
      outcome: passthrough
      error_code: passthrough
      created_at: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS encryption_events (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        entity_table VARCHAR(64) NOT NULL,
        entity_pk VARCHAR(64) NOT NULL,
        field_name VARCHAR(64) NOT NULL,
        op TEXT NOT NULL,
        policy_id BIGINT NULL,
        local_key_version VARCHAR(64) NULL,
        layers JSONB NULL,
        outcome TEXT NOT NULL,
        error_code VARCHAR(64) NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT chk_enc_op CHECK (op IN ('encrypt','decrypt','rotate','rehash','unwrap','wrap')),
        CONSTRAINT chk_enc_outcome CHECK (outcome IN ('success','failure'))
      );
    foreign_keys:
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_enc_events_entity ON encryption_events (entity_table, entity_pk, created_at)
  deletion_jobs:
    Crypto:
      id: passthrough
      entity_table: passthrough
      entity_pk: passthrough
      reason: passthrough
      hard_delete: passthrough
      scheduled_at: passthrough
      started_at: passthrough
      finished_at: passthrough
      status: passthrough
      error: passthrough
      created_by: passthrough
      created_at: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS deletion_jobs (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        entity_table VARCHAR(64) NOT NULL,
        entity_pk    VARCHAR(64) NOT NULL,
        reason TEXT NULL,
        hard_delete BOOLEAN NOT NULL DEFAULT FALSE,
        scheduled_at TIMESTAMPTZ(6) NULL,
        started_at   TIMESTAMPTZ(6) NULL,
        finished_at  TIMESTAMPTZ(6) NULL,
        status TEXT NOT NULL DEFAULT 'pending',
        error TEXT NULL,
        created_by BIGINT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT uq_deletion_jobs UNIQUE (entity_table, entity_pk),
        CONSTRAINT chk_dj_status CHECK (status IN ('pending','running','done','failed','cancelled'))
      );
    UpdatedAt: finished_at
    DefaultOrder: created_at DESC
    Upsert:
      Update:
        - reason
        - hard_delete
        - scheduled_at
        - started_at
        - finished_at
        - status
        - error
        - created_by
      Keys:
        - entity_table
        - entity_pk
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_dj_status_sched ON deletion_jobs (status, scheduled_at)
    foreign_keys:
      - ALTER TABLE deletion_jobs ADD CONSTRAINT fk_dj_user FOREIGN KEY (created_by) REFERENCES users(id) ON DELETE SET NULL
  categories:
    Crypto:
      id: passthrough
      tenant_id: passthrough
      name: passthrough
      name_ci: passthrough
      slug: passthrough
      slug_ci: passthrough
      parent_id: passthrough
      created_at: passthrough
      updated_at: passthrough
      version: passthrough
      deleted_at: passthrough
      is_live: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS categories (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        tenant_id BIGINT NOT NULL,
        name VARCHAR(255) NOT NULL,
        name_ci TEXT GENERATED ALWAYS AS (lower(name)) STORED,
        slug VARCHAR(255) NOT NULL,
        slug_ci TEXT GENERATED ALWAYS AS (lower(slug)) STORED,
        parent_id BIGINT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        version INTEGER NOT NULL DEFAULT 0,
        CONSTRAINT chk_categories_version CHECK (version >= 0),
        deleted_at TIMESTAMPTZ(6) NULL,
        is_live BOOLEAN GENERATED ALWAYS AS (deleted_at IS NULL) STORED
      );
    UpdatedAt: updated_at
    DefaultOrder: id DESC
    Upsert:
      Update:
        - name
        - parent_id
        - deleted_at
        - updated_at
        - version
      Keys:
        - tenant_id
        - slug_ci
    indexes:
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_categories_tenant_slug_live_ci ON categories (tenant_id, slug_ci, is_live)
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_categories_tenant_id ON categories (tenant_id, id)
      - CREATE INDEX IF NOT EXISTS idx_categories_tenant_parent ON categories (tenant_id, parent_id)
      - CREATE INDEX IF NOT EXISTS idx_categories_name_ci ON categories (tenant_id, name_ci)
      - CREATE INDEX IF NOT EXISTS idx_categories_tenant_parent ON categories (tenant_id, parent_id)
      - CREATE INDEX IF NOT EXISTS idx_categories_parent ON categories (parent_id)
      - CREATE INDEX IF NOT EXISTS idx_categories_name_ci ON categories (tenant_id, lower(name))
    SoftDelete: deleted_at
    foreign_keys:
      - ALTER TABLE categories ADD CONSTRAINT fk_categories_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE RESTRICT
      - ALTER TABLE categories ADD CONSTRAINT fk_categories_parent FOREIGN KEY (parent_id) REFERENCES categories(id) ON DELETE SET NULL
  crypto_algorithms:
    Crypto:
      id: passthrough
      class: passthrough
      name: passthrough
      variant: passthrough
      variant_norm: passthrough
      nist_level: passthrough
      status: passthrough
      params: passthrough
      created_at: passthrough
    DefaultOrder: id DESC
    create: |-
      CREATE TABLE IF NOT EXISTS crypto_algorithms (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        class TEXT NOT NULL,                       -- 'kem' | 'sig' | 'hash' | 'symmetric'
        name  VARCHAR(120) NOT NULL,               -- e.g. 'ML-KEM-768','ML-DSA-2','SHA3-512','AES-256-GCM'
        variant VARCHAR(80) NULL,                  -- e.g. 'hybrid-x25519', 'fips-202'
        variant_norm TEXT GENERATED ALWAYS AS (COALESCE(variant,'')) STORED,
        nist_level SMALLINT NULL,                  -- 1..5 for PQC, NULL for others
        status TEXT NOT NULL DEFAULT 'active',     -- 'active' | 'deprecated' | 'experimental'
        params JSONB NULL,                         -- e.g. { "ct_max_len": 1792, "pubkey_len": 1184 }
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT uq_crypto_algorithms UNIQUE (class, name, variant_norm),
        CONSTRAINT uq_crypto_algorithms_raw UNIQUE (class, name, variant),
        CONSTRAINT chk_ca_class CHECK (class IN ('kem','sig','hash','symmetric')),
        CONSTRAINT chk_ca_status CHECK (status IN ('active','deprecated','experimental'))
      );
    foreign_keys:
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_ca_class_status ON crypto_algorithms (class, status)
    Upsert:
      Update:
        - nist_level
        - status
        - params
      Keys:
        - class
        - name
        - variant
  reviews:
    Crypto:
      id: passthrough
      tenant_id: passthrough
      book_id: passthrough
      user_id: passthrough
      rating: passthrough
      review_text: passthrough
      created_at: passthrough
      updated_at: passthrough
    UpdatedAt: updated_at
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS reviews (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        tenant_id BIGINT NOT NULL,
        book_id BIGINT NOT NULL,
        user_id BIGINT NULL,
        rating SMALLINT NOT NULL,
        review_text TEXT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NULL,
        CONSTRAINT chk_reviews_rating CHECK (rating BETWEEN 1 AND 5)
      );
    foreign_keys:
      - ALTER TABLE reviews ADD CONSTRAINT fk_reviews_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE RESTRICT
      - ALTER TABLE reviews ADD CONSTRAINT fk_reviews_book FOREIGN KEY (tenant_id, book_id) REFERENCES books(tenant_id, id) ON DELETE CASCADE
      - ALTER TABLE reviews ADD CONSTRAINT fk_reviews_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL
    indexes:
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_reviews_tenant_book_user ON reviews (tenant_id, book_id, user_id)
      - CREATE INDEX IF NOT EXISTS idx_reviews_tenant_book ON reviews (tenant_id, book_id)
      - CREATE INDEX IF NOT EXISTS idx_reviews_created_at ON reviews (created_at)
      - CREATE INDEX IF NOT EXISTS idx_reviews_user_id ON reviews (user_id)
      - CREATE INDEX IF NOT EXISTS idx_reviews_book_id ON reviews (book_id)
  idempotency_keys:
    Crypto:
      key_hash:
        strategy: hmac
        context: db.hmac.idempotency_keys.key_hash
        encoding: hex
      key_hash_key_version: passthrough
      tenant_id: passthrough
      payment_id: passthrough
      order_id: passthrough
      gateway_payload: passthrough
      redirect_url: passthrough
      created_at: passthrough
      ttl_seconds: passthrough
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS idempotency_keys (
        key_hash CHAR(64) NOT NULL PRIMARY KEY,
        key_hash_key_version VARCHAR(64) NULL,
        tenant_id BIGINT NOT NULL,
        payment_id BIGINT NULL DEFAULT NULL,
        order_id BIGINT NULL DEFAULT NULL,
        gateway_payload JSONB NULL,
        redirect_url VARCHAR(1024) NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        ttl_seconds INTEGER NOT NULL DEFAULT 86400
      );
    foreign_keys:
      - ALTER TABLE idempotency_keys ADD CONSTRAINT fk_idemp_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE RESTRICT
      - ALTER TABLE idempotency_keys ADD CONSTRAINT fk_idemp_payment FOREIGN KEY (tenant_id, payment_id) REFERENCES payments(tenant_id, id) ON DELETE CASCADE
      - ALTER TABLE idempotency_keys ADD CONSTRAINT fk_idemp_order   FOREIGN KEY (tenant_id, order_id)   REFERENCES orders(tenant_id, id) ON DELETE CASCADE
      - ALTER TABLE idempotency_keys ADD CONSTRAINT chk_idemp_ttl CHECK (ttl_seconds > 0)
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_idemp_payment ON idempotency_keys (payment_id)
      - CREATE INDEX IF NOT EXISTS idx_idemp_order ON idempotency_keys (order_id)
      - CREATE INDEX IF NOT EXISTS idx_idemp_created_at ON idempotency_keys (created_at)
      - CREATE INDEX IF NOT EXISTS idx_idemp_tenant_payment ON idempotency_keys (tenant_id, payment_id)
      - CREATE INDEX IF NOT EXISTS idx_idemp_tenant_order   ON idempotency_keys (tenant_id, order_id)
    Upsert:
      Update:
        - payment_id
        - order_id
        - gateway_payload
        - redirect_url
        - ttl_seconds
      Keys:
        - key_hash
  pq_migration_jobs:
    Crypto:
      id: passthrough
      scope: passthrough
      target_policy_id: passthrough
      target_algo_id: passthrough
      selection: passthrough
      scheduled_at: passthrough
      started_at: passthrough
      finished_at: passthrough
      status: passthrough
      processed_count: passthrough
      error: passthrough
      created_by: passthrough
      created_at: passthrough
    UpdatedAt: finished_at
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS pq_migration_jobs (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        scope TEXT NOT NULL,                         -- 'hashes' | 'wrappers' | 'signatures'
        target_policy_id BIGINT NULL,                -- encryption_policies.id (when switching the policy)
        target_algo_id BIGINT NULL,                  -- crypto_algorithms.id (e.g. ML-KEM-768)
        selection JSONB NULL,                        -- e.g. { "table": "encrypted_fields", "field": "ciphertext" }
        scheduled_at TIMESTAMPTZ(6) NULL,
        started_at   TIMESTAMPTZ(6) NULL,
        finished_at  TIMESTAMPTZ(6) NULL,
        status TEXT NOT NULL DEFAULT 'pending',      -- 'pending','running','done','failed','cancelled'
        processed_count BIGINT NOT NULL DEFAULT 0,
        error TEXT NULL,
        created_by BIGINT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT chk_pq_mig_status CHECK (status IN ('pending','running','done','failed','cancelled'))
      );
    foreign_keys:
      - ALTER TABLE pq_migration_jobs ADD CONSTRAINT fk_pq_mig_policy FOREIGN KEY (target_policy_id) REFERENCES encryption_policies(id) ON DELETE SET NULL
      - ALTER TABLE pq_migration_jobs ADD CONSTRAINT fk_pq_mig_algo   FOREIGN KEY (target_algo_id)   REFERENCES crypto_algorithms(id) ON DELETE SET NULL
      - ALTER TABLE pq_migration_jobs ADD CONSTRAINT fk_pq_mig_user   FOREIGN KEY (created_by)       REFERENCES users(id) ON DELETE SET NULL
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_pq_mig_status_sched ON pq_migration_jobs (status, scheduled_at)
  policy_kms_keys:
    Crypto:
      policy_id: passthrough
      kms_key_id: passthrough
      weight: passthrough
      priority: passthrough
      created_at: passthrough
      updated_at: passthrough
    DefaultOrder: policy_id DESC, kms_key_id DESC
    create: |-
      CREATE TABLE IF NOT EXISTS policy_kms_keys (
        policy_id BIGINT NOT NULL,
        kms_key_id BIGINT NOT NULL,
        weight INTEGER NOT NULL DEFAULT 1,
        priority INTEGER NOT NULL DEFAULT 0,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        PRIMARY KEY (policy_id, kms_key_id)
      );
    foreign_keys:
      - ALTER TABLE policy_kms_keys ADD CONSTRAINT fk_policy_kms_keys_policy FOREIGN KEY (policy_id) REFERENCES encryption_policies(id) ON DELETE CASCADE
      - ALTER TABLE policy_kms_keys ADD CONSTRAINT fk_policy_kms_keys_key FOREIGN KEY (kms_key_id) REFERENCES kms_keys(id) ON DELETE CASCADE
    indexes:
    Upsert:
      Update:
        - weight
        - priority
      Keys:
        - policy_id
        - kms_key_id
  sync_batches:
    Crypto:
      id: passthrough
      channel: passthrough
      producer_peer_id: passthrough
      consumer_peer_id: passthrough
      status: passthrough
      items_total: passthrough
      items_ok: passthrough
      items_failed: passthrough
      error: passthrough
      created_at: passthrough
      started_at: passthrough
      finished_at: passthrough
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS sync_batches (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        channel VARCHAR(120) NOT NULL,
        producer_peer_id BIGINT NOT NULL,
        consumer_peer_id BIGINT NOT NULL,
        status TEXT NOT NULL DEFAULT 'pending',
        items_total INTEGER NOT NULL DEFAULT 0,
        items_ok    INTEGER NOT NULL DEFAULT 0,
        items_failed INTEGER NOT NULL DEFAULT 0,
        error TEXT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        started_at  TIMESTAMPTZ(6) NULL,
        finished_at TIMESTAMPTZ(6) NULL,
        CONSTRAINT chk_sync_batches_status CHECK (status IN ('pending','sending','completed','failed','cancelled'))
      );
    foreign_keys:
      - ALTER TABLE sync_batches ADD CONSTRAINT fk_sb_producer FOREIGN KEY (producer_peer_id) REFERENCES peer_nodes(id) ON DELETE RESTRICT
      - ALTER TABLE sync_batches ADD CONSTRAINT fk_sb_consumer FOREIGN KEY (consumer_peer_id) REFERENCES peer_nodes(id) ON DELETE RESTRICT
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_sync_batches_status ON sync_batches (status)
      - CREATE INDEX IF NOT EXISTS idx_sync_batches_created ON sync_batches (created_at)
    Upsert:
      Update:
        - status
        - items_total
        - items_ok
        - items_failed
        - error
        - started_at
        - finished_at
      Keys:
        - id
  encryption_bindings:
    Crypto:
      id: passthrough
      entity_table: passthrough
      entity_pk: passthrough
      field_name: passthrough
      field_name_norm: passthrough
      key_wrapper_id: passthrough
      created_at: passthrough
    DefaultOrder: id DESC
    create: |-
      CREATE TABLE IF NOT EXISTS encryption_bindings (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        entity_table VARCHAR(64) NOT NULL,
        entity_pk VARCHAR(64) NOT NULL,
        field_name VARCHAR(64) NULL,
        field_name_norm VARCHAR(64) GENERATED ALWAYS AS (COALESCE(field_name,'')) STORED,
        key_wrapper_id BIGINT NOT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT uq_enc_bind UNIQUE (entity_table, entity_pk, field_name_norm),
        CONSTRAINT uq_enc_bind_raw UNIQUE (entity_table, entity_pk, field_name)
      );
    foreign_keys:
      - ALTER TABLE encryption_bindings ADD CONSTRAINT fk_enc_bind_kw FOREIGN KEY (key_wrapper_id) REFERENCES key_wrappers(id) ON DELETE RESTRICT
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_enc_bind_entity ON encryption_bindings (entity_table, entity_pk, created_at)
    Upsert:
      Update:
        - key_wrapper_id
      Keys:
        - entity_table
        - entity_pk
        - field_name
  peer_nodes:
    Crypto:
      id: passthrough
      name: passthrough
      type: passthrough
      location: passthrough
      status: passthrough
      last_seen: passthrough
      meta: passthrough
      created_at: passthrough
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS peer_nodes (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name VARCHAR(120) NOT NULL,
        "type" TEXT NOT NULL,
        location VARCHAR(120) NULL,
        status TEXT NOT NULL DEFAULT 'active',
        last_seen TIMESTAMPTZ(6) NULL,
        meta JSONB NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT chk_peer_type CHECK ("type" IN ('postgres','mysql','app','service')),
        CONSTRAINT chk_peer_status CHECK (status IN ('active','offline','degraded','disabled'))
      );
    foreign_keys:
    indexes:
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_peer_nodes_name ON peer_nodes (name)
      - CREATE INDEX IF NOT EXISTS idx_peer_nodes_status ON peer_nodes (status)
      - CREATE INDEX IF NOT EXISTS idx_peer_nodes_last_seen ON peer_nodes (last_seen)
    Upsert:
      Update:
        - type
        - location
        - status
        - last_seen
        - meta
      Keys:
        - name
  rbac_user_permissions:
    Crypto:
      id: passthrough
      user_id: passthrough
      permission_id: passthrough
      tenant_id: passthrough
      scope: passthrough
      effect: passthrough
      granted_by: passthrough
      granted_at: passthrough
      expires_at: passthrough
    DefaultOrder: granted_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS rbac_user_permissions (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        user_id BIGINT NOT NULL,
        permission_id BIGINT NOT NULL,
        tenant_id BIGINT NULL,
        scope VARCHAR(120) NULL,
        effect TEXT NOT NULL DEFAULT 'allow',           -- 'allow' | 'deny'
        granted_by BIGINT NULL,
        granted_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        expires_at TIMESTAMPTZ(6) NULL,
        CONSTRAINT uq_rbac_user_perm UNIQUE (user_id, permission_id, tenant_id, scope),
        CONSTRAINT chk_rbac_user_perm_effect CHECK (effect IN ('allow','deny'))
      );
    foreign_keys:
      - ALTER TABLE rbac_user_permissions ADD CONSTRAINT fk_rbac_up_user  FOREIGN KEY (user_id)  REFERENCES users(id) ON DELETE CASCADE
      - ALTER TABLE rbac_user_permissions ADD CONSTRAINT fk_rbac_up_perm  FOREIGN KEY (permission_id) REFERENCES permissions(id) ON DELETE CASCADE
      - ALTER TABLE rbac_user_permissions ADD CONSTRAINT fk_rbac_up_grant FOREIGN KEY (granted_by) REFERENCES users(id) ON DELETE SET NULL
      - ALTER TABLE rbac_user_permissions ADD CONSTRAINT fk_rbac_up_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE CASCADE
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_rbac_up_user ON rbac_user_permissions (user_id)
      - CREATE INDEX IF NOT EXISTS idx_rbac_up_perm ON rbac_user_permissions (permission_id)
    Upsert:
      Update:
        - effect
        - granted_by
        - granted_at
        - expires_at
      Keys:
        - user_id
        - permission_id
        - tenant_id
        - scope
  kms_health_checks:
    Crypto:
      id: passthrough
      provider_id: passthrough
      kms_key_id: passthrough
      status: passthrough
      latency_ms: passthrough
      error: passthrough
      checked_at: passthrough
    DefaultOrder: checked_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS kms_health_checks (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        provider_id BIGINT NULL,
        kms_key_id  BIGINT NULL,
        status TEXT NOT NULL,                           -- 'up','degraded','down'
        latency_ms INTEGER NULL,
        error TEXT NULL,
        checked_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT chk_kms_hc_status CHECK (status IN ('up','degraded','down'))
      );
    foreign_keys:
      - ALTER TABLE kms_health_checks ADD CONSTRAINT fk_kms_hc_provider FOREIGN KEY (provider_id) REFERENCES kms_providers(id) ON DELETE SET NULL
      - ALTER TABLE kms_health_checks ADD CONSTRAINT fk_kms_hc_key      FOREIGN KEY (kms_key_id)  REFERENCES kms_keys(id) ON DELETE SET NULL
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_kms_hc_provider_time ON kms_health_checks (provider_id, checked_at)
      - CREATE INDEX IF NOT EXISTS idx_kms_hc_key_time ON kms_health_checks (kms_key_id, checked_at)
  email_verifications:
    Crypto:
      id: passthrough
      user_id: passthrough
      token_hash:
        strategy: hmac
        context: db.hmac.email_verifications
        encoding: hex
        write_key_version: true
        key_version_column: key_version
      selector: passthrough
      validator_hash:
        strategy: hmac
        context: db.hmac.email_verifications
        write_key_version: true
        key_version_column: key_version
      key_version: passthrough
      expires_at: passthrough
      created_at: passthrough
      used_at: passthrough
    DefaultOrder: id DESC
    create: |-
      CREATE TABLE IF NOT EXISTS email_verifications (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        user_id BIGINT NOT NULL,
        token_hash CHAR(64) NULL,
        selector CHAR(12) NOT NULL,
        validator_hash BYTEA NULL,
        key_version VARCHAR(64) NULL,
        expires_at TIMESTAMPTZ(6) NOT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        used_at TIMESTAMPTZ(6) NULL
      );
    foreign_keys:
      - ALTER TABLE email_verifications ADD CONSTRAINT fk_ev_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
    indexes:
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_ev_selector ON email_verifications (selector)
      - CREATE INDEX IF NOT EXISTS idx_ev_user ON email_verifications (user_id)
      - CREATE INDEX IF NOT EXISTS idx_ev_expires ON email_verifications (expires_at)
    Upsert:
      Update:
        - user_id
        - token_hash
        - validator_hash
        - key_version
        - expires_at
        - created_at
        - used_at
      Keys:
        - selector
  password_resets:
    Crypto:
      id: passthrough
      user_id: passthrough
      token_hash:
        strategy: hmac
        context: db.hmac.password_resets
        encoding: hex
        write_key_version: true
        key_version_column: key_version
      selector: passthrough
      validator_hash:
        strategy: hmac
        context: db.hmac.password_resets
        write_key_version: true
        key_version_column: key_version
      key_version: passthrough
      expires_at: passthrough
      created_at: passthrough
      used_at: passthrough
      ip_hash:
        strategy: hmac
        context: db.hmac.password_resets.ip_hash
        write_key_version: true
        key_version_column: ip_hash_key_version
      ip_hash_key_version: passthrough
      user_agent: passthrough
    DefaultOrder: id DESC
    create: |-
      CREATE TABLE IF NOT EXISTS password_resets (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        user_id BIGINT NOT NULL,
        token_hash CHAR(64) NULL,
        selector CHAR(12) NOT NULL,
        validator_hash BYTEA NULL,
        key_version VARCHAR(64) NULL,
        expires_at TIMESTAMPTZ(6) NOT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        used_at TIMESTAMPTZ(6) NULL,
        ip_hash BYTEA NULL,
        ip_hash_key_version VARCHAR(64) NULL,
        user_agent VARCHAR(1024) NULL
      );
    foreign_keys:
      - ALTER TABLE password_resets ADD CONSTRAINT fk_pr_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
    indexes:
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_pr_selector ON password_resets (selector)
      - CREATE INDEX IF NOT EXISTS idx_pr_user ON password_resets (user_id)
      - CREATE INDEX IF NOT EXISTS idx_pr_expires ON password_resets (expires_at)
      - CREATE INDEX IF NOT EXISTS idx_pr_used ON password_resets (used_at)
      - CREATE INDEX IF NOT EXISTS idx_pr_ip_hash ON password_resets (ip_hash)
    Upsert:
      Update:
        - user_id
        - token_hash
        - validator_hash
        - key_version
        - expires_at
        - created_at
        - used_at
        - ip_hash
        - ip_hash_key_version
        - user_agent
      Keys:
        - selector
  device_codes:
    Crypto:
      id: passthrough
      device_code_hash:
        strategy: hmac
        context: db.hmac.device_codes.device_code_hash
        write_key_version: true
        key_version_column: device_code_hash_key_version
      device_code_hash_key_version: passthrough
      device_code: passthrough
      device_code_key_version: passthrough
      user_code_hash:
        strategy: hmac
        context: db.hmac.device_codes.user_code_hash
        write_key_version: true
        key_version_column: user_code_hash_key_version
      user_code_hash_key_version: passthrough
      client_id: passthrough
      scopes: passthrough
      token_payload: passthrough
      token_payload_key_version: passthrough
      interval_sec: passthrough
      approved_at: passthrough
      expires_at: passthrough
      created_at: passthrough
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS device_codes (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        device_code_hash BYTEA NOT NULL,
        device_code_hash_key_version VARCHAR(64) NULL,
        device_code BYTEA NOT NULL,
        device_code_key_version VARCHAR(64) NULL,
        user_code_hash BYTEA NOT NULL,
        user_code_hash_key_version VARCHAR(64) NULL,
        client_id VARCHAR(128) NOT NULL,
        scopes JSONB NOT NULL DEFAULT '[]'::jsonb,
        token_payload BYTEA NULL,
        token_payload_key_version VARCHAR(64) NULL,
        interval_sec INTEGER NOT NULL DEFAULT 5,
        approved_at TIMESTAMPTZ(6) NULL,
        expires_at TIMESTAMPTZ(6) NOT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT ux_device_codes_device_code_hash UNIQUE (device_code_hash),
        CONSTRAINT ux_device_codes_user_code_hash UNIQUE (user_code_hash),
        CONSTRAINT chk_device_codes_interval CHECK (interval_sec >= 0)
      );
    foreign_keys:
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_device_codes_expires ON device_codes (expires_at)
      - CREATE INDEX IF NOT EXISTS idx_device_codes_client ON device_codes (client_id)
      - CREATE INDEX IF NOT EXISTS idx_device_codes_approved ON device_codes (approved_at)
    Upsert:
      Update:
        - token_payload
        - token_payload_key_version
        - approved_at
      Keys:
        - device_code_hash
  magic_links:
    Crypto:
      id: passthrough
      fingerprint: passthrough
      subject: passthrough
      user_id: passthrough
      context: passthrough
      expires_at: passthrough
      created_at: passthrough
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS magic_links (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        fingerprint CHAR(64) NOT NULL,
        subject VARCHAR(128) NOT NULL,
        user_id BIGINT NULL,
        context JSONB NULL,
        expires_at TIMESTAMPTZ(6) NOT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT ux_magic_links_fingerprint UNIQUE (fingerprint)
      );
    foreign_keys:
      - ALTER TABLE magic_links ADD CONSTRAINT fk_magic_links_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_magic_links_user ON magic_links (user_id)
      - CREATE INDEX IF NOT EXISTS idx_magic_links_subject ON magic_links (subject)
      - CREATE INDEX IF NOT EXISTS idx_magic_links_expires ON magic_links (expires_at)
    Upsert:
      Update:
        - subject
        - user_id
        - context
        - expires_at
      Keys:
        - fingerprint
  webauthn_credentials:
    Crypto:
      id: passthrough
      rp_id: passthrough
      subject: passthrough
      user_id: passthrough
      credential_id: passthrough
      public_key: passthrough
      added_at: passthrough
      created_at: passthrough
      last_used_at: passthrough
      sign_count: passthrough
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS webauthn_credentials (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        rp_id VARCHAR(255) NOT NULL,
        subject VARCHAR(128) NOT NULL,
        user_id BIGINT NULL,
        credential_id VARCHAR(255) NOT NULL,
        public_key TEXT NOT NULL,
        added_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        last_used_at TIMESTAMPTZ(6) NULL,
        sign_count BIGINT NOT NULL DEFAULT 0,
        CONSTRAINT ux_webauthn_cred UNIQUE (rp_id, credential_id)
      );
    foreign_keys:
      - ALTER TABLE webauthn_credentials ADD CONSTRAINT fk_webauthn_cred_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_webauthn_cred_subject ON webauthn_credentials (rp_id, subject)
      - CREATE INDEX IF NOT EXISTS idx_webauthn_cred_user ON webauthn_credentials (user_id)
      - CREATE INDEX IF NOT EXISTS idx_webauthn_cred_last_used ON webauthn_credentials (last_used_at)
    Upsert:
      Update:
        - subject
        - user_id
        - public_key
        - added_at
        - last_used_at
      Keys:
        - rp_id
        - credential_id
  webauthn_challenges:
    Crypto:
      id: passthrough
      rp_id: passthrough
      challenge_hash: passthrough
      metadata: passthrough
      expires_at: passthrough
      created_at: passthrough
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS webauthn_challenges (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        rp_id VARCHAR(255) NOT NULL,
        challenge_hash CHAR(64) NOT NULL,
        metadata JSONB NOT NULL,
        expires_at TIMESTAMPTZ(6) NOT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT ux_webauthn_challenge UNIQUE (rp_id, challenge_hash)
      );
    foreign_keys:
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_webauthn_challenge_expires ON webauthn_challenges (expires_at)
    Upsert:
      Update:
        - metadata
        - expires_at
      Keys:
        - rp_id
        - challenge_hash
  rewrap_jobs:
    Crypto:
      id: passthrough
      key_wrapper_id: passthrough
      target_kms1_key_id: passthrough
      target_kms2_key_id: passthrough
      scheduled_at: passthrough
      started_at: passthrough
      finished_at: passthrough
      status: passthrough
      attempts: passthrough
      last_error: passthrough
      created_at: passthrough
    UpdatedAt: finished_at
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS rewrap_jobs (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        key_wrapper_id BIGINT NOT NULL,
        target_kms1_key_id BIGINT NULL,
        target_kms2_key_id BIGINT NULL,
        scheduled_at TIMESTAMPTZ(6) NULL,
        started_at   TIMESTAMPTZ(6) NULL,
        finished_at  TIMESTAMPTZ(6) NULL,
        status TEXT NOT NULL DEFAULT 'pending',
        attempts INTEGER NOT NULL DEFAULT 0,
        last_error TEXT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT chk_rewrap_status CHECK (status IN ('pending','running','done','failed')),
        CONSTRAINT chk_rewrap_attempts CHECK (attempts >= 0)
      );
    foreign_keys:
      - ALTER TABLE rewrap_jobs ADD CONSTRAINT fk_rewrap_kw FOREIGN KEY (key_wrapper_id) REFERENCES key_wrappers(id) ON DELETE CASCADE
      - ALTER TABLE rewrap_jobs ADD CONSTRAINT fk_rewrap_tk1 FOREIGN KEY (target_kms1_key_id) REFERENCES kms_keys(id) ON DELETE SET NULL
      - ALTER TABLE rewrap_jobs ADD CONSTRAINT fk_rewrap_tk2 FOREIGN KEY (target_kms2_key_id) REFERENCES kms_keys(id) ON DELETE SET NULL
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_rewrap_status_sched ON rewrap_jobs (status, scheduled_at)
      - CREATE INDEX IF NOT EXISTS idx_rewrap_kw ON rewrap_jobs (key_wrapper_id)
  system_errors:
    Crypto:
      id: passthrough
      level: passthrough
      message: passthrough
      exception_class: passthrough
      file: passthrough
      line: passthrough
      stack_trace: passthrough
      token: passthrough
      context: passthrough
      fingerprint: passthrough
      occurrences: passthrough
      user_id: passthrough
      ip_hash:
        strategy: hmac
        context: db.hmac.system_errors.ip_hash
        write_key_version: true
        key_version_column: ip_hash_key_version
      ip_hash_key_version: passthrough
      user_agent: passthrough
      url: passthrough
      method: passthrough
      http_status: passthrough
      resolved: passthrough
      resolved_by: passthrough
      resolved_at: passthrough
      created_at: passthrough
      last_seen: passthrough
    DefaultOrder: last_seen DESC
    create: |-
      CREATE TABLE IF NOT EXISTS system_errors (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        level TEXT NOT NULL,
        message TEXT NOT NULL,
        exception_class VARCHAR(255) NULL,
        file VARCHAR(1024) NULL,
        line INTEGER NULL,
        stack_trace TEXT NULL,
        token VARCHAR(255) NULL,
        context JSONB NULL,
        fingerprint VARCHAR(64) NULL,
        occurrences INTEGER NOT NULL DEFAULT 1,
        CONSTRAINT chk_system_errors_occurrences CHECK (occurrences >= 0),
        user_id BIGINT NULL,
        ip_hash BYTEA NULL,
        ip_hash_key_version VARCHAR(64) NULL,
        user_agent VARCHAR(1024) NULL,
        url VARCHAR(2048) NULL,
        method VARCHAR(10) NULL,
        http_status SMALLINT NULL,
        resolved BOOLEAN NOT NULL DEFAULT FALSE,
        resolved_by BIGINT NULL,
        resolved_at TIMESTAMPTZ(6) NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        last_seen TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT chk_err_level CHECK (level IN ('notice','warning','error','critical')),
        CONSTRAINT uq_err_fp UNIQUE (fingerprint),
        CONSTRAINT chk_system_errors_http_status CHECK (http_status IS NULL OR http_status >= 0)
      );
    foreign_keys:
      - ALTER TABLE system_errors ADD CONSTRAINT fk_err_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL
      - ALTER TABLE system_errors ADD CONSTRAINT fk_err_resolved_by FOREIGN KEY (resolved_by) REFERENCES users(id) ON DELETE SET NULL
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_err_level ON system_errors (level)
      - CREATE INDEX IF NOT EXISTS idx_err_time ON system_errors (created_at)
      - CREATE INDEX IF NOT EXISTS idx_err_user ON system_errors (user_id)
      - CREATE INDEX IF NOT EXISTS idx_err_ip ON system_errors (ip_hash)
      - CREATE INDEX IF NOT EXISTS idx_err_resolved ON system_errors (resolved)
      - CREATE INDEX IF NOT EXISTS idx_system_errors_last_seen ON system_errors (last_seen)
      - CREATE INDEX IF NOT EXISTS gin_system_errors_ctx    ON system_errors USING GIN (context jsonb_path_ops)
    Upsert:
      Update:
        - level
        - message
        - exception_class
        - file
        - line
        - stack_trace
        - token
        - context
        - occurrences
        - user_id
        - ip_hash
        - ip_hash_key_version
        - user_agent
        - url
        - method
        - http_status
        - resolved
        - resolved_by
        - resolved_at
        - last_seen
      Keys:
        - fingerprint
  rbac_role_permissions:
    Crypto:
      role_id: passthrough
      permission_id: passthrough
      effect: passthrough
      source: passthrough
      created_at: passthrough
    DefaultOrder: role_id DESC
    create: |-
      CREATE TABLE IF NOT EXISTS rbac_role_permissions (
        role_id BIGINT NOT NULL,
        permission_id BIGINT NOT NULL,
        effect TEXT NOT NULL DEFAULT 'allow',           -- 'allow' | 'deny'
        source TEXT NOT NULL DEFAULT 'repo',            -- 'repo' | 'local'
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        PRIMARY KEY (role_id, permission_id),
        CONSTRAINT chk_rbac_role_perm_effect CHECK (effect IN ('allow','deny')),
        CONSTRAINT chk_rbac_role_perm_source CHECK (source IN ('repo','local'))
      );
    foreign_keys:
      - ALTER TABLE rbac_role_permissions ADD CONSTRAINT fk_rbac_rp_role FOREIGN KEY (role_id) REFERENCES rbac_roles(id) ON DELETE CASCADE
      - ALTER TABLE rbac_role_permissions ADD CONSTRAINT fk_rbac_rp_perm FOREIGN KEY (permission_id) REFERENCES permissions(id) ON DELETE CASCADE
    indexes:
    Upsert:
      Update:
        - effect
        - source
      Keys:
        - role_id
        - permission_id
  verify_events:
    Crypto:
      id: passthrough
      user_id: passthrough
      type: passthrough
      ip_hash:
        strategy: hmac
        context: db.hmac.verify_events.ip_hash
        write_key_version: true
        key_version_column: ip_hash_key_version
      ip_hash_key_version: passthrough
      user_agent: passthrough
      occurred_at: passthrough
      meta: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS verify_events (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        user_id BIGINT NULL,
        type TEXT NOT NULL,
        ip_hash BYTEA NULL,
        ip_hash_key_version VARCHAR(64) NULL,
        user_agent VARCHAR(1024) NULL,
        occurred_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        meta JSONB NULL,
        CONSTRAINT chk_verify_type CHECK (type IN ('verify_success','verify_failure'))
      );
    foreign_keys:
      - ALTER TABLE verify_events ADD CONSTRAINT fk_verify_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_ver_user ON verify_events (user_id)
      - CREATE INDEX IF NOT EXISTS idx_ver_time ON verify_events (occurred_at)
      - CREATE INDEX IF NOT EXISTS idx_ver_type_time ON verify_events (type, occurred_at)
      - CREATE INDEX IF NOT EXISTS idx_ver_ip ON verify_events (ip_hash)
  payment_logs:
    Crypto:
      id: passthrough
      payment_id: passthrough
      log_at: passthrough
      message: passthrough
    DefaultOrder: log_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS payment_logs (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        payment_id BIGINT NOT NULL,
        log_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        message TEXT NOT NULL
      );
    foreign_keys:
      - ALTER TABLE payment_logs ADD CONSTRAINT fk_payment_logs_payment FOREIGN KEY (payment_id) REFERENCES payments(id) ON DELETE CASCADE
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_payment_logs_payment ON payment_logs (payment_id, log_at DESC)
  encryption_policy_bindings:
    Crypto:
      id: passthrough
      entity_table: passthrough
      field_name: passthrough
      policy_id: passthrough
      effective_from: passthrough
      notes: passthrough
      created_at: passthrough
      updated_at: passthrough
    DefaultOrder: effective_from DESC
    create: |-
      CREATE TABLE IF NOT EXISTS encryption_policy_bindings (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        entity_table VARCHAR(64) NOT NULL,
        field_name   VARCHAR(64) NOT NULL,
        policy_id    BIGINT NOT NULL,
        effective_from TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        notes TEXT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT uq_enc_policy_bind UNIQUE (entity_table, field_name, effective_from)
      );
    foreign_keys:
      - ALTER TABLE encryption_policy_bindings ADD CONSTRAINT fk_enc_pol_bind_policy FOREIGN KEY (policy_id) REFERENCES encryption_policies(id) ON DELETE CASCADE
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_enc_pol_bind_entity ON encryption_policy_bindings (entity_table, field_name, effective_from)
    Upsert:
      Update:
        - policy_id
        - notes
      Keys:
        - entity_table
        - field_name
        - effective_from
  book_categories:
    Crypto:
      tenant_id: passthrough
      book_id: passthrough
      category_id: passthrough
      created_at: passthrough
      updated_at: passthrough
    DefaultOrder: tenant_id DESC, book_id DESC, category_id DESC
    create: |-
      CREATE TABLE IF NOT EXISTS book_categories (
        tenant_id  BIGINT NOT NULL,
        book_id    BIGINT NOT NULL,
        category_id BIGINT NOT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        PRIMARY KEY (tenant_id, book_id, category_id)
      );
    foreign_keys:
      - ALTER TABLE book_categories ADD CONSTRAINT fk_book_categories_book FOREIGN KEY (tenant_id, book_id) REFERENCES books(tenant_id, id) ON DELETE CASCADE
      - ALTER TABLE book_categories ADD CONSTRAINT fk_book_categories_category FOREIGN KEY (tenant_id, category_id) REFERENCES categories(tenant_id, id) ON DELETE CASCADE
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_book_categories_category ON book_categories (category_id)
      - CREATE INDEX IF NOT EXISTS idx_book_categories_book ON book_categories (book_id)
      - CREATE INDEX IF NOT EXISTS idx_book_categories_tenant ON book_categories (tenant_id)
    Upsert:
      Update:
      Keys:
        - tenant_id
        - book_id
        - category_id
  key_events:
    Crypto:
      id: passthrough
      key_id: passthrough
      basename: passthrough
      event_type: passthrough
      actor_id: passthrough
      job_id: passthrough
      note: passthrough
      meta: passthrough
      source: passthrough
      created_at: passthrough
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS key_events (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        key_id BIGINT NULL,
        basename VARCHAR(100) NULL,
        event_type TEXT NOT NULL,
        actor_id BIGINT NULL,
        job_id BIGINT NULL,
        note TEXT NULL,
        meta JSONB NULL,
        "source" TEXT NOT NULL DEFAULT 'admin',
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT chk_key_events_type CHECK (event_type IN ('created','rotated','activated','retired','compromised','deleted','used_encrypt','used_decrypt','access_failed','backup','restore')),
        CONSTRAINT chk_key_events_source CHECK ("source" IN ('cron','admin','api','manual'))
      );
    foreign_keys:
      - ALTER TABLE key_events ADD CONSTRAINT fk_key_events_key FOREIGN KEY (key_id) REFERENCES crypto_keys(id) ON DELETE SET NULL
      - ALTER TABLE key_events ADD CONSTRAINT fk_key_events_actor FOREIGN KEY (actor_id) REFERENCES users(id) ON DELETE SET NULL
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_key_events_key_created ON key_events (key_id, created_at)
      - CREATE INDEX IF NOT EXISTS idx_key_events_basename ON key_events (basename)
  slo_status:
    Crypto:
      id: passthrough
      window_id: passthrough
      computed_at: passthrough
      sli_value: passthrough
      good_events: passthrough
      total_events: passthrough
      status: passthrough
    DefaultOrder: computed_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS slo_status (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        window_id BIGINT NOT NULL,
        computed_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        sli_value NUMERIC(18,6) NULL,
        good_events BIGINT NOT NULL DEFAULT 0,
        total_events BIGINT NOT NULL DEFAULT 0,
        status TEXT NOT NULL DEFAULT 'unknown',       -- 'good','breach','unknown'
        CONSTRAINT uq_slo_status_window UNIQUE (window_id, computed_at),
        CONSTRAINT chk_slo_status CHECK (status IN ('good','breach','unknown'))
      );
    foreign_keys:
      - ALTER TABLE slo_status ADD CONSTRAINT fk_slo_status_window FOREIGN KEY (window_id) REFERENCES slo_windows(id) ON DELETE CASCADE
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_slo_status_window ON slo_status (window_id, computed_at)
    Upsert:
      Update:
        - sli_value
        - good_events
        - total_events
        - status
      Keys:
        - window_id
        - computed_at
  permissions:
    Crypto:
      id: passthrough
      name: passthrough
      description: passthrough
      created_at: passthrough
      updated_at: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS permissions (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name VARCHAR(100) NOT NULL UNIQUE,
        description TEXT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6)
      );
    UpdatedAt: updated_at
    DefaultOrder: id DESC
    Upsert:
      Update:
        - description
      Keys:
        - name
    indexes:
    foreign_keys:
  coupons:
    Crypto:
      id: passthrough
      tenant_id: passthrough
      code: passthrough
      code_ci: passthrough
      type: passthrough
      value: passthrough
      currency: passthrough
      starts_at: passthrough
      ends_at: passthrough
      max_redemptions: passthrough
      min_order_amount: passthrough
      applies_to: passthrough
      is_active: passthrough
      created_at: passthrough
      updated_at: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS coupons (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        tenant_id BIGINT NOT NULL,
        code VARCHAR(100) NOT NULL,
        code_ci TEXT GENERATED ALWAYS AS (lower(code)) STORED,
        type TEXT NOT NULL,
        value NUMERIC(12,2) NOT NULL,
        currency CHAR(3) NULL,
        starts_at DATE NOT NULL,
        ends_at DATE NULL,
        max_redemptions INTEGER NOT NULL DEFAULT 0,
        min_order_amount NUMERIC(12,2) NULL,
        applies_to JSONB NULL,
        is_active BOOLEAN NOT NULL DEFAULT TRUE,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT chk_coupon_percent_fixed
          CHECK (
            (type='percent' AND value BETWEEN 0 AND 100 AND currency IS NULL)
            OR
            (type='fixed'   AND value >= 0 AND currency ~ '^[A-Z]{3}$')
          ),
        CONSTRAINT chk_coupons_range
          CHECK (ends_at IS NULL OR ends_at >= starts_at)
      );
    UpdatedAt: updated_at
    DefaultOrder: id DESC
    Upsert:
      Update:
        - type
        - value
        - currency
        - starts_at
        - ends_at
        - max_redemptions
        - min_order_amount
        - applies_to
        - is_active
        - updated_at
      Keys:
        - tenant_id
        - code_ci
    indexes:
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_coupons_tenant_code_ci ON coupons (tenant_id, code_ci)
      - CREATE INDEX IF NOT EXISTS idx_coupons_tenant_active ON coupons (tenant_id, is_active)
      - CREATE UNIQUE INDEX IF NOT EXISTS idx_coupons_tenant_id ON coupons (tenant_id, id)
    foreign_keys:
      - ALTER TABLE coupons ADD CONSTRAINT fk_coupons_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE RESTRICT
  migration_events:
    Crypto:
      id: passthrough
      system_name: passthrough
      from_version: passthrough
      to_version: passthrough
      status: passthrough
      started_at: passthrough
      finished_at: passthrough
      error: passthrough
      meta: passthrough
    DefaultOrder: started_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS migration_events (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        system_name VARCHAR(120) NOT NULL,
        from_version VARCHAR(64) NULL,
        to_version   VARCHAR(64) NOT NULL,
        status TEXT NOT NULL DEFAULT 'pending',
        started_at   TIMESTAMPTZ(6) NULL,
        finished_at  TIMESTAMPTZ(6) NULL,
        error TEXT NULL,
        meta JSONB NULL,
        CONSTRAINT chk_mig_status CHECK (status IN ('pending','running','done','failed','cancelled'))
      );
    foreign_keys:
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_mig_system_status ON migration_events (system_name, status)
      - CREATE INDEX IF NOT EXISTS idx_mig_started ON migration_events (started_at)
  encryption_policies:
    Crypto:
      id: passthrough
      policy_name: passthrough
      mode: passthrough
      layer_selection: passthrough
      min_layers: passthrough
      max_layers: passthrough
      aad_template: passthrough
      notes: passthrough
      created_at: passthrough
    DefaultOrder: id DESC
    create: |-
      CREATE TABLE IF NOT EXISTS encryption_policies (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        policy_name VARCHAR(100) NOT NULL UNIQUE,
        mode TEXT NOT NULL,
        layer_selection TEXT NOT NULL DEFAULT 'defined',
        min_layers SMALLINT NOT NULL DEFAULT 1,
        max_layers SMALLINT NOT NULL DEFAULT 3,
        aad_template JSONB NULL,
        notes TEXT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT chk_enc_mode CHECK (mode IN ('local','kms','multi-kms')),
        CONSTRAINT chk_enc_layer_selection CHECK (layer_selection IN ('defined','round_robin','random','hash_mod'))
      );
    foreign_keys:
    indexes:
    Upsert:
      Update:
        - mode
        - layer_selection
        - min_layers
        - max_layers
        - aad_template
        - notes
      Keys:
        - policy_name
  rbac_repositories:
    Crypto:
      id: passthrough
      name: passthrough
      url: passthrough
      signing_key_id: passthrough
      status: passthrough
      last_synced_at: passthrough
      last_commit: passthrough
      created_at: passthrough
    DefaultOrder: id DESC
    create: |-
      CREATE TABLE IF NOT EXISTS rbac_repositories (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name VARCHAR(120) NOT NULL,
        url  VARCHAR(1024) NULL,
        signing_key_id BIGINT NULL,                      -- optional: verify snapshot signatures
        status TEXT NOT NULL DEFAULT 'active',           -- 'active','disabled'
        last_synced_at TIMESTAMPTZ(6) NULL,
        last_commit VARCHAR(128) NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6)
      );
    foreign_keys:
      - ALTER TABLE rbac_repositories ADD CONSTRAINT fk_rbac_repos_sign_key FOREIGN KEY (signing_key_id) REFERENCES signing_keys(id) ON DELETE SET NULL
    indexes:
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_rbac_repositories_name ON rbac_repositories (name)
      - CREATE INDEX IF NOT EXISTS idx_rbac_repos_status ON rbac_repositories (status)
    Upsert:
      Update:
        - url
        - signing_key_id
        - status
        - last_synced_at
        - last_commit
      Keys:
        - name
  register_events:
    Crypto:
      id: passthrough
      user_id: passthrough
      type: passthrough
      ip_hash:
        strategy: hmac
        context: db.hmac.register_events.ip_hash
        write_key_version: true
        key_version_column: ip_hash_key_version
      ip_hash_key_version: passthrough
      user_agent: passthrough
      occurred_at: passthrough
      meta: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS register_events (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        user_id BIGINT NULL,
        type TEXT NOT NULL,
        ip_hash BYTEA NULL,
        ip_hash_key_version VARCHAR(64) NULL,
        user_agent VARCHAR(1024) NULL,
        occurred_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        meta JSONB NULL,
        CONSTRAINT chk_register_type CHECK (type IN ('register_success','register_failure'))
      );
    foreign_keys:
      - ALTER TABLE register_events ADD CONSTRAINT fk_register_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_reg_user ON register_events (user_id)
      - CREATE INDEX IF NOT EXISTS idx_reg_time ON register_events (occurred_at)
      - CREATE INDEX IF NOT EXISTS idx_reg_type_time ON register_events (type, occurred_at)
      - CREATE INDEX IF NOT EXISTS idx_reg_ip ON register_events (ip_hash)
  hash_profiles:
    Crypto:
      id: passthrough
      name: passthrough
      algo_id: passthrough
      output_len: passthrough
      params: passthrough
      status: passthrough
      created_at: passthrough
    DefaultOrder: id DESC
    create: |-
      CREATE TABLE IF NOT EXISTS hash_profiles (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name VARCHAR(120) NOT NULL,
        algo_id BIGINT NOT NULL,                    -- crypto_algorithms (class='hash'), e.g. SHA3-512
        output_len SMALLINT NULL,                   -- in bytes; NULL = full length
        params JSONB NULL,                          -- e.g. { "peppered": true, "context": "email", "domain_sep": "app:v1" }
        status TEXT NOT NULL DEFAULT 'active',
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT uq_hash_profiles UNIQUE (name),
        CONSTRAINT chk_hp_status CHECK (status IN ('active','deprecated'))
      );
    foreign_keys:
      - ALTER TABLE hash_profiles ADD CONSTRAINT fk_hp_algo FOREIGN KEY (algo_id) REFERENCES crypto_algorithms(id) ON DELETE RESTRICT
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_hp_algo_status ON hash_profiles (algo_id, status)
    Upsert:
      Update:
        - algo_id
        - output_len
        - params
        - status
      Keys:
        - name
  invoice_items:
    Crypto:
      id: passthrough
      tenant_id: passthrough
      invoice_id: passthrough
      line_no: passthrough
      description: passthrough
      unit_price: passthrough
      quantity: passthrough
      tax_rate: passthrough
      tax_amount: passthrough
      line_total: passthrough
      currency: passthrough
      created_at: passthrough
      updated_at: passthrough
    DefaultOrder: invoice_id DESC, line_no DESC
    create: |-
      CREATE TABLE IF NOT EXISTS invoice_items (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        tenant_id BIGINT NOT NULL,
        invoice_id BIGINT NOT NULL,
        line_no INTEGER NOT NULL,
        description TEXT NOT NULL,
        unit_price NUMERIC(12,2) NOT NULL,
        quantity INTEGER NOT NULL,
        tax_rate NUMERIC(5,2) NOT NULL,
        tax_amount NUMERIC(12,2) NOT NULL,
        line_total NUMERIC(12,2) NOT NULL,
        currency CHAR(3) NOT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT uq_invoice_line UNIQUE (invoice_id, line_no),
        CONSTRAINT chk_invoice_items_currency CHECK (currency ~ '^[A-Z]{3}$'),
        CONSTRAINT chk_invoice_items_qty CHECK (quantity > 0),
        CONSTRAINT chk_invoice_items_nonneg CHECK (unit_price >= 0 AND tax_amount >= 0 AND line_total >= 0)
      );
    foreign_keys:
      - ALTER TABLE invoice_items ADD CONSTRAINT fk_invoice_items_invoice FOREIGN KEY (tenant_id, invoice_id) REFERENCES invoices(tenant_id, id) ON DELETE CASCADE
      - ALTER TABLE invoice_items ADD CONSTRAINT chk_invoice_items_tax_rate CHECK (tax_rate BETWEEN 0 AND 100)
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_invoice_items_tenant_invoice ON invoice_items (tenant_id, invoice_id)
    Upsert:
      Update:
        - description
        - unit_price
        - quantity
        - tax_rate
        - tax_amount
        - line_total
        - currency
      Keys:
        - invoice_id
        - line_no
  refunds:
    Crypto:
      id: passthrough
      tenant_id: passthrough
      payment_id: passthrough
      amount: passthrough
      currency: passthrough
      reason: passthrough
      status: passthrough
      created_at: passthrough
      details: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS refunds (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        tenant_id BIGINT NOT NULL,
        payment_id BIGINT NOT NULL,
        amount NUMERIC(12,2) NOT NULL,
        currency CHAR(3) NOT NULL,
        reason TEXT NULL,
        status VARCHAR(50) NOT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        details JSONB NULL,
        CONSTRAINT chk_refunds_currency CHECK (currency ~ '^[A-Z]{3}$')
      );
    foreign_keys:
      - ALTER TABLE refunds ADD CONSTRAINT fk_refunds_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE RESTRICT
      - ALTER TABLE refunds ADD CONSTRAINT fk_refunds_payment FOREIGN KEY (tenant_id, payment_id) REFERENCES payments(tenant_id, id) ON DELETE CASCADE
      - ALTER TABLE refunds ADD CONSTRAINT chk_refunds_amount CHECK (amount >= 0)
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_refunds_payment ON refunds (payment_id)
      - CREATE INDEX IF NOT EXISTS idx_refunds_tenant_payment ON refunds (tenant_id, payment_id)
  rbac_roles:
    Crypto:
      id: passthrough
      repo_id: passthrough
      slug: passthrough
      name: passthrough
      description: passthrough
      version: passthrough
      status: passthrough
      created_at: passthrough
      updated_at: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS rbac_roles (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        repo_id BIGINT NULL,
        slug VARCHAR(120) NOT NULL,                      -- stable role identifier
        name VARCHAR(200) NOT NULL,
        description TEXT NULL,
        version INTEGER NOT NULL DEFAULT 1,
        status  TEXT NOT NULL DEFAULT 'active',          -- 'active','deprecated','archived'
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT uq_rbac_roles_repo_slug UNIQUE (repo_id, slug),
        CONSTRAINT chk_rbac_roles_status CHECK (status IN ('active','deprecated','archived'))
      );
    UpdatedAt: updated_at
    DefaultOrder: id DESC
    Upsert:
      Update:
        - name
        - description
        - version
        - status
        - updated_at
      Keys:
        - repo_id
        - slug
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_rbac_roles_repo ON rbac_roles (repo_id)
      - CREATE INDEX IF NOT EXISTS idx_rbac_roles_status ON rbac_roles (status)
    foreign_keys:
      - ALTER TABLE rbac_roles ADD CONSTRAINT fk_rbac_roles_repo FOREIGN KEY (repo_id) REFERENCES rbac_repositories(id) ON DELETE SET NULL
  authors:
    Crypto:
      id: passthrough
      tenant_id: passthrough
      name: passthrough
      name_ci: passthrough
      slug: passthrough
      slug_ci: passthrough
      bio: passthrough
      photo_url: passthrough
      story: passthrough
      books_count: passthrough
      ratings_count: passthrough
      rating_sum: passthrough
      avg_rating: passthrough
      last_rating_at: passthrough
      created_at: passthrough
      updated_at: passthrough
      version: passthrough
      deleted_at: passthrough
      is_live: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS authors (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        tenant_id BIGINT NOT NULL,
        name VARCHAR(255) NOT NULL,
        name_ci TEXT GENERATED ALWAYS AS (lower(name)) STORED,
        slug VARCHAR(255) NOT NULL,
        slug_ci TEXT GENERATED ALWAYS AS (lower(slug)) STORED,
        bio TEXT NULL,
        photo_url VARCHAR(255) NULL,
        story TEXT NULL,
        books_count INTEGER NOT NULL DEFAULT 0,
        ratings_count INTEGER NOT NULL DEFAULT 0,
        rating_sum INTEGER NOT NULL DEFAULT 0,
        avg_rating NUMERIC(3,2) NULL DEFAULT NULL,
        last_rating_at TIMESTAMPTZ(6) NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        version INTEGER NOT NULL DEFAULT 0,
        CONSTRAINT chk_authors_version CHECK (version >= 0),
        deleted_at TIMESTAMPTZ(6) NULL,
        is_live BOOLEAN GENERATED ALWAYS AS (deleted_at IS NULL) STORED
      );
    UpdatedAt: updated_at
    DefaultOrder: id DESC
    Upsert:
      Update:
        - name
        - bio
        - photo_url
        - story
        - books_count
        - ratings_count
        - rating_sum
        - avg_rating
        - last_rating_at
        - deleted_at
        - updated_at
        - version
      Keys:
        - tenant_id
        - slug_ci
    indexes:
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_authors_tenant_slug_live_ci ON authors (tenant_id, slug_ci, is_live)
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_authors_tenant_id ON authors (tenant_id, id)
      - CREATE INDEX IF NOT EXISTS idx_authors_avg_rating ON authors (avg_rating)
      - CREATE INDEX IF NOT EXISTS idx_authors_books_count ON authors (books_count)
      - CREATE INDEX IF NOT EXISTS idx_authors_name_ci   ON authors (tenant_id, name_ci)
    SoftDelete: deleted_at
    foreign_keys:
      - ALTER TABLE authors ADD CONSTRAINT fk_authors_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE RESTRICT
  tax_rates:
    Crypto:
      id: passthrough
      country_iso2: passthrough
      category: passthrough
      rate: passthrough
      valid_from: passthrough
      valid_to: passthrough
      created_at: passthrough
      updated_at: passthrough
    DefaultOrder: valid_from DESC
    create: |-
      CREATE TABLE IF NOT EXISTS tax_rates (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        country_iso2 CHAR(2) NOT NULL,
        category TEXT NOT NULL,
        rate NUMERIC(5,2) NOT NULL,
        valid_from DATE NOT NULL,
        valid_to DATE NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT chk_tax_category CHECK (category IN ('ebook','physical')),
        CONSTRAINT chk_tax_valid_span CHECK (valid_to IS NULL OR valid_to >= valid_from)
      );
    foreign_keys:
      - ALTER TABLE tax_rates ADD CONSTRAINT fk_tax_rates_country FOREIGN KEY (country_iso2) REFERENCES countries(iso2) ON DELETE CASCADE
      - ALTER TABLE tax_rates ADD CONSTRAINT chk_tax_rates_rate CHECK (rate BETWEEN 0 AND 100)
    indexes:
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_tax_rates_country_cat_from ON tax_rates (country_iso2, category, valid_from)
    Upsert:
      Update:
        - rate
        - valid_to
      Keys:
        - country_iso2
        - category
        - valid_from
  sync_batch_items:
    Crypto:
      id: passthrough
      batch_id: passthrough
      event_key: passthrough
      status: passthrough
      error: passthrough
      created_at: passthrough
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS sync_batch_items (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        batch_id BIGINT NOT NULL,
        event_key CHAR(36) NOT NULL,
        status TEXT NOT NULL DEFAULT 'pending',
        error TEXT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT uq_sync_batch_event UNIQUE (batch_id, event_key),
        CONSTRAINT chk_sbi_status CHECK (status IN ('pending','sent','applied','failed','skipped'))
      );
    foreign_keys:
      - ALTER TABLE sync_batch_items ADD CONSTRAINT fk_sbi_batch FOREIGN KEY (batch_id) REFERENCES sync_batches(id) ON DELETE CASCADE
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_sbi_batch ON sync_batch_items (batch_id)
      - CREATE INDEX IF NOT EXISTS idx_sbi_status ON sync_batch_items (status)
    Upsert:
      Update:
        - status
        - error
      Keys:
        - batch_id
        - event_key
  worker_locks:
    Crypto:
      name: passthrough
      locked_until: passthrough
      created_at: passthrough
      updated_at: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS worker_locks (
        name VARCHAR(191) NOT NULL PRIMARY KEY,
        locked_until TIMESTAMPTZ(6) NOT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6)
      );
    foreign_keys:
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_worker_locks_until ON worker_locks (locked_until)
  webhook_outbox:
    Crypto:
      id: passthrough
      event_type: passthrough
      payload: passthrough
      status: passthrough
      retries: passthrough
      next_attempt_at: passthrough
      created_at: passthrough
      updated_at: passthrough
      version: passthrough
    UpdatedAt: updated_at
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS webhook_outbox (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        event_type VARCHAR(100) NOT NULL,
        payload JSONB NULL,
        status TEXT NOT NULL DEFAULT 'pending',
        retries INTEGER NOT NULL DEFAULT 0,
        next_attempt_at TIMESTAMPTZ(6) NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        version INTEGER NOT NULL DEFAULT 0,
        CONSTRAINT chk_webhook_outbox_version CHECK (version >= 0),
        CONSTRAINT chk_webhook_status CHECK (status IN ('pending','sent','failed'))
      );
    foreign_keys:
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_webhook_status_scheduled ON webhook_outbox (status, next_attempt_at)
      - CREATE INDEX IF NOT EXISTS idx_webhook_created_at ON webhook_outbox (created_at)
  slo_windows:
    Crypto:
      id: passthrough
      name: passthrough
      objective: passthrough
      target_pct: passthrough
      window_interval: passthrough
      created_at: passthrough
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS slo_windows (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name VARCHAR(120) NOT NULL,
        objective JSONB NOT NULL,                     -- {"metric":"outbox_latency_sec","threshold":10,"percentile":95}
        target_pct NUMERIC(5,2) NOT NULL,
        window_interval INTERVAL NOT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6)
      );
    foreign_keys:
    indexes:
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_slo_windows_name ON slo_windows (name)
    Upsert:
      Update:
        - objective
        - target_pct
        - window_interval
      Keys:
        - name
  newsletter_subscribers:
    Crypto:
      id: passthrough
      tenant_id: passthrough
      user_id: passthrough
      email_hash:
        strategy: hmac
        context: db.hmac.newsletter_subscribers.email_hash
        write_key_version: true
        key_version_column: email_hash_key_version
      email_hash_key_version: passthrough
      email_enc:
        strategy: encrypt
        context: db.vault.newsletter_subscribers.email_enc
        write_key_version: true
        key_version_column: email_key_version
      email_key_version: passthrough
      confirm_selector: passthrough
      confirm_validator_hash:
        strategy: hmac
        context: db.hmac.newsletter_subscribers.confirm_validator_hash
        write_key_version: true
        key_version_column: confirm_key_version
      confirm_key_version: passthrough
      confirm_expires: passthrough
      confirmed_at: passthrough
      unsubscribe_token_hash:
        strategy: hmac
        context: db.hmac.newsletter_subscribers.unsubscribe_token_hash
        write_key_version: true
        key_version_column: unsubscribe_token_key_version
      unsubscribe_token_key_version: passthrough
      unsubscribed_at: passthrough
      origin: passthrough
      ip_hash:
        strategy: hmac
        context: db.hmac.newsletter_subscribers.ip_hash
        write_key_version: true
        key_version_column: ip_hash_key_version
      ip_hash_key_version: passthrough
      meta: passthrough
      created_at: passthrough
      updated_at: passthrough
      version: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS newsletter_subscribers (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        tenant_id BIGINT NOT NULL,
        user_id BIGINT NULL,
        email_hash BYTEA NOT NULL,
        email_hash_key_version VARCHAR(64) NULL,
        email_enc BYTEA NULL,
        email_key_version VARCHAR(64) NULL,
        confirm_selector CHAR(12) DEFAULT NULL,
        confirm_validator_hash BYTEA DEFAULT NULL,
        confirm_key_version VARCHAR(64) DEFAULT NULL,
        confirm_expires TIMESTAMPTZ(6) DEFAULT NULL,
        confirmed_at TIMESTAMPTZ(6) DEFAULT NULL,
        unsubscribe_token_hash BYTEA DEFAULT NULL,
        unsubscribe_token_key_version VARCHAR(64) DEFAULT NULL,
        unsubscribed_at TIMESTAMPTZ(6) DEFAULT NULL,
        origin VARCHAR(100) DEFAULT NULL,
        ip_hash BYTEA DEFAULT NULL,
        ip_hash_key_version VARCHAR(64) DEFAULT NULL,
        meta JSONB DEFAULT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        version INTEGER NOT NULL DEFAULT 0,
        CONSTRAINT chk_ns_version CHECK (version >= 0)
      );
    UpdatedAt: updated_at
    DefaultOrder: id DESC
    Upsert:
      Update:
        - user_id
        - email_hash_key_version
        - email_enc
        - email_key_version
        - confirm_selector
        - confirm_validator_hash
        - confirm_key_version
        - confirm_expires
        - confirmed_at
        - unsubscribe_token_hash
        - unsubscribe_token_key_version
        - unsubscribed_at
        - origin
        - ip_hash
        - ip_hash_key_version
        - meta
        - updated_at
        - version
      Keys:
        - tenant_id
        - email_hash
    indexes:
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_ns_tenant_email_hash ON newsletter_subscribers (tenant_id, email_hash)
      - CREATE INDEX IF NOT EXISTS idx_ns_tenant ON newsletter_subscribers (tenant_id)
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_ns_confirm_selector ON newsletter_subscribers (confirm_selector)
      - CREATE INDEX IF NOT EXISTS idx_ns_user ON newsletter_subscribers (user_id)
      - CREATE INDEX IF NOT EXISTS idx_ns_confirm_expires ON newsletter_subscribers (confirm_expires)
      - CREATE INDEX IF NOT EXISTS idx_ns_unsubscribed_at ON newsletter_subscribers (unsubscribed_at)
      - CREATE INDEX IF NOT EXISTS idx_ns_confirmed_at ON newsletter_subscribers (confirmed_at)
    foreign_keys:
      - ALTER TABLE newsletter_subscribers ADD CONSTRAINT fk_ns_user   FOREIGN KEY (user_id)   REFERENCES users(id) ON DELETE SET NULL
      - ALTER TABLE newsletter_subscribers ADD CONSTRAINT fk_ns_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE RESTRICT
  coupon_redemptions:
    Crypto:
      id: passthrough
      tenant_id: passthrough
      coupon_id: passthrough
      user_id: passthrough
      order_id: passthrough
      redeemed_at: passthrough
      amount_applied: passthrough
    DefaultOrder: redeemed_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS coupon_redemptions (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        tenant_id BIGINT NOT NULL,
        coupon_id BIGINT NOT NULL,
        user_id BIGINT NOT NULL,
        order_id BIGINT NOT NULL,
        redeemed_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        amount_applied NUMERIC(12,2) NOT NULL
      );
    foreign_keys:
      - ALTER TABLE coupon_redemptions ADD CONSTRAINT fk_cr_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE RESTRICT
      - ALTER TABLE coupon_redemptions ADD CONSTRAINT fk_cr_coupon FOREIGN KEY (tenant_id, coupon_id) REFERENCES coupons(tenant_id, id) ON DELETE CASCADE
      - ALTER TABLE coupon_redemptions ADD CONSTRAINT fk_cr_order  FOREIGN KEY (tenant_id, order_id)  REFERENCES orders(tenant_id, id) ON DELETE CASCADE
      - ALTER TABLE coupon_redemptions ADD CONSTRAINT fk_cr_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_cr_coupon ON coupon_redemptions (coupon_id)
      - CREATE INDEX IF NOT EXISTS idx_cr_user   ON coupon_redemptions (user_id)
      - CREATE INDEX IF NOT EXISTS idx_cr_order  ON coupon_redemptions (order_id)
      - CREATE INDEX IF NOT EXISTS idx_cr_tenant_coupon ON coupon_redemptions (tenant_id, coupon_id)
      - CREATE INDEX IF NOT EXISTS idx_cr_tenant_user   ON coupon_redemptions (tenant_id, user_id)
      - CREATE INDEX IF NOT EXISTS idx_cr_tenant_order  ON coupon_redemptions (tenant_id, order_id)
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_cr_tenant_order_coupon ON coupon_redemptions (tenant_id, order_id, coupon_id)
  system_jobs:
    Crypto:
      id: passthrough
      job_type: passthrough
      payload: passthrough
      status: passthrough
      retries: passthrough
      scheduled_at: passthrough
      started_at: passthrough
      finished_at: passthrough
      error: passthrough
      unique_key_hash:
        strategy: hmac
        context: db.hmac.system_jobs.unique_key_hash
        encoding: hex
        write_key_version: true
        key_version_column: unique_key_version
      unique_key_version: passthrough
      locked_until: passthrough
      locked_by: passthrough
      created_at: passthrough
      updated_at: passthrough
      version: passthrough
    UpdatedAt: updated_at
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS system_jobs (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        job_type VARCHAR(100) NOT NULL,
        payload JSONB NULL,
        status TEXT NOT NULL DEFAULT 'pending',
        retries INTEGER NOT NULL DEFAULT 0,
        scheduled_at TIMESTAMPTZ(6) NULL,
        started_at TIMESTAMPTZ(6) NULL,
        finished_at TIMESTAMPTZ(6) NULL,
        error TEXT NULL,
        unique_key_hash CHAR(64) NULL,
        unique_key_version VARCHAR(64) NULL,
        locked_until TIMESTAMPTZ(6) NULL,
        locked_by VARCHAR(100) NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        version INTEGER NOT NULL DEFAULT 0,
        CONSTRAINT chk_system_jobs_version CHECK (version >= 0),
        CONSTRAINT chk_system_jobs_status CHECK (status IN ('pending','processing','done','failed')),
        CONSTRAINT chk_system_jobs_retries CHECK (retries >= 0)
      );
    foreign_keys:
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_system_jobs_status_sched ON system_jobs (status, scheduled_at)
      - CREATE INDEX IF NOT EXISTS idx_system_jobs_locked_until ON system_jobs (locked_until)
  policy_algorithms:
    Crypto:
      policy_id: passthrough
      algo_id: passthrough
      role: passthrough
      weight: passthrough
      priority: passthrough
      created_at: passthrough
      updated_at: passthrough
    DefaultOrder: policy_id DESC, priority DESC
    create: |-
      CREATE TABLE IF NOT EXISTS policy_algorithms (
        policy_id BIGINT NOT NULL,
        algo_id   BIGINT NOT NULL,
        role TEXT NOT NULL,                        -- 'kem' | 'sig' | 'hash' | 'symmetric'
        weight INTEGER NOT NULL DEFAULT 1,
        priority INTEGER NOT NULL DEFAULT 0,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        PRIMARY KEY (policy_id, algo_id, role),
        CONSTRAINT chk_pa_role CHECK (role IN ('kem','sig','hash','symmetric'))
      );
    foreign_keys:
      - ALTER TABLE policy_algorithms ADD CONSTRAINT fk_pa_policy FOREIGN KEY (policy_id) REFERENCES encryption_policies(id) ON DELETE CASCADE
      - ALTER TABLE policy_algorithms ADD CONSTRAINT fk_pa_algo   FOREIGN KEY (algo_id)   REFERENCES crypto_algorithms(id) ON DELETE CASCADE
    indexes:
    Upsert:
      Update:
        - weight
        - priority
      Keys:
        - policy_id
        - algo_id
        - role
  rbac_sync_cursors:
    Crypto:
      repo_id: passthrough
      peer: passthrough
      last_commit: passthrough
      last_synced_at: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS rbac_sync_cursors (
        repo_id BIGINT NOT NULL,
        peer VARCHAR(120) NOT NULL,                    -- consumer identifier (application/DB)
        last_commit VARCHAR(128) NULL,
        last_synced_at TIMESTAMPTZ(6) NULL,
        PRIMARY KEY (repo_id, peer)
      );
    foreign_keys:
      - ALTER TABLE rbac_sync_cursors ADD CONSTRAINT fk_rbac_cursors_repo FOREIGN KEY (repo_id) REFERENCES rbac_repositories(id) ON DELETE CASCADE
    indexes:
    Upsert:
      Update:
        - last_commit
        - last_synced_at
      Keys:
        - repo_id
        - peer
  two_factor:
    Crypto:
      user_id: passthrough
      method: passthrough
      secret:
        strategy: encrypt
        context: db.vault.two_factor.secret
      secret_key_version: passthrough
      recovery_codes_enc:
        strategy: encrypt
        context: db.vault.two_factor.recovery_codes_enc
      recovery_codes_enc_key_version: passthrough
      hotp_counter: passthrough
      enabled: passthrough
      created_at: passthrough
      version: passthrough
      last_used_at: passthrough
    DefaultOrder: user_id DESC, method DESC
    create: |-
      CREATE TABLE IF NOT EXISTS two_factor (
        user_id BIGINT NOT NULL,
        method VARCHAR(50) NOT NULL,
        secret BYTEA NULL,
        secret_key_version VARCHAR(64) NULL,
        recovery_codes_enc BYTEA NULL,
        recovery_codes_enc_key_version VARCHAR(64) NULL,
        hotp_counter BIGINT NULL,
        enabled BOOLEAN NOT NULL DEFAULT FALSE,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        version INTEGER NOT NULL DEFAULT 0,
        CONSTRAINT chk_two_factor_version CHECK (version >= 0),
        last_used_at TIMESTAMPTZ(6) NULL,
        PRIMARY KEY (user_id, method),
        CONSTRAINT chk_two_factor_hotp_counter CHECK (hotp_counter IS NULL OR hotp_counter >= 0),
        CONSTRAINT chk_two_factor_method CHECK (method IN ('totp','hotp','webauthn','sms','email'))
      );
    foreign_keys:
      - ALTER TABLE two_factor ADD CONSTRAINT fk_two_factor_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
    indexes:
    Upsert:
      Update:
        - secret
        - secret_key_version
        - recovery_codes_enc
        - recovery_codes_enc_key_version
        - hotp_counter
        - enabled
        - last_used_at
      Keys:
        - user_id
        - method
  key_wrappers:
    Crypto:
      id: passthrough
      wrapper_uuid: passthrough
      kms1_key_id: passthrough
      kms2_key_id: passthrough
      dek_wrap1: passthrough
      dek_wrap2: passthrough
      crypto_suite: passthrough
      wrap_version: passthrough
      status: passthrough
      created_at: passthrough
      rotated_at: passthrough
    DefaultOrder: id DESC
    create: |-
      CREATE TABLE IF NOT EXISTS key_wrappers (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        wrapper_uuid CHAR(36) NOT NULL,
        kms1_key_id BIGINT NOT NULL,
        kms2_key_id BIGINT NOT NULL,
        dek_wrap1 BYTEA NOT NULL,
        dek_wrap2 BYTEA NOT NULL,
        crypto_suite JSONB NULL,
        wrap_version INTEGER NOT NULL DEFAULT 1,
        status TEXT NOT NULL DEFAULT 'active',
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        rotated_at TIMESTAMPTZ(6) NULL,
        CONSTRAINT uq_key_wrappers_uuid UNIQUE (wrapper_uuid),
        CONSTRAINT chk_kw_status CHECK (status IN ('active','rotated','retired','invalid'))
      );
    foreign_keys:
      - ALTER TABLE key_wrappers ADD CONSTRAINT fk_kw_kms1 FOREIGN KEY (kms1_key_id) REFERENCES kms_keys(id) ON DELETE RESTRICT
      - ALTER TABLE key_wrappers ADD CONSTRAINT fk_kw_kms2 FOREIGN KEY (kms2_key_id) REFERENCES kms_keys(id) ON DELETE RESTRICT
    indexes:
      - CREATE UNIQUE INDEX IF NOT EXISTS ux_kw_k1_k2_version ON key_wrappers (kms1_key_id, kms2_key_id, wrap_version)
      - CREATE INDEX IF NOT EXISTS idx_kw_status_created ON key_wrappers (status, created_at)
    Upsert:
      Update:
        - kms1_key_id
        - kms2_key_id
        - dek_wrap1
        - dek_wrap2
        - crypto_suite
        - wrap_version
        - status
        - rotated_at
      Keys:
        - wrapper_uuid
  countries:
    Crypto:
      iso2: passthrough
      name: passthrough
      created_at: passthrough
      updated_at: passthrough
    DefaultOrder: iso2 ASC
    create: |-
      CREATE TABLE IF NOT EXISTS countries (
        iso2 CHAR(2) PRIMARY KEY,
        name VARCHAR(100) NOT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT chk_countries_iso2 CHECK (iso2 ~ '^[A-Z]{2}$')
      );
    foreign_keys:
    indexes:
    Upsert:
      Update:
        - name
      Keys:
        - iso2
  auth_events:
    Crypto:
      id: passthrough
      user_id: passthrough
      type: passthrough
      ip_hash:
        strategy: hmac
        context: db.hmac.auth_events.ip_hash
        write_key_version: true
        key_version_column: ip_hash_key_version
      ip_hash_key_version: passthrough
      user_agent: passthrough
      occurred_at: passthrough
      meta: passthrough
      meta_email: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS auth_events (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        user_id BIGINT NULL,
        type TEXT NOT NULL,
        ip_hash BYTEA NULL,
        ip_hash_key_version VARCHAR(64) NULL,
        user_agent VARCHAR(1024) NULL,
        occurred_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        meta JSONB NULL,
        meta_email TEXT GENERATED ALWAYS AS (meta ->> 'email') STORED,
        CONSTRAINT chk_auth_type CHECK (type IN ('login_success','login_failure','logout','password_reset','lockout','magic_link_request','magic_link_throttled','magic_link_email_queued','device_code_issue','device_code_issue_failure','device_code_activate_success','device_code_activate_failure','device_code_poll_success','device_code_poll_failure','webauthn_register_success','webauthn_register_failure','webauthn_login_success','webauthn_login_failure'))
      );
    foreign_keys:
      - ALTER TABLE auth_events ADD CONSTRAINT fk_auth_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_auth_meta_email ON auth_events (meta_email)
      - CREATE INDEX IF NOT EXISTS idx_auth_user ON auth_events (user_id)
      - CREATE INDEX IF NOT EXISTS idx_auth_time ON auth_events (occurred_at)
      - CREATE INDEX IF NOT EXISTS idx_auth_type_time ON auth_events (type, occurred_at)
      - CREATE INDEX IF NOT EXISTS idx_auth_ip_hash ON auth_events (ip_hash)
      - CREATE INDEX IF NOT EXISTS gin_auth_events_meta ON auth_events   USING GIN (meta jsonb_path_ops)
  audit_log:
    Crypto:
      id: passthrough
      table_name: passthrough
      record_id: passthrough
      changed_by: passthrough
      change_type: passthrough
      old_value: passthrough
      new_value: passthrough
      changed_at: passthrough
      ip_bin:
        strategy: hmac
        context: db.hmac.audit_log.ip_bin
      ip_bin_key_version: passthrough
      user_agent: passthrough
      request_id: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS audit_log (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        table_name VARCHAR(100) NOT NULL,
        record_id BIGINT NOT NULL,
        changed_by BIGINT NULL,
        change_type TEXT NOT NULL,
        old_value JSONB NULL,
        new_value JSONB NULL,
        changed_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        ip_bin BYTEA NULL,
        ip_bin_key_version VARCHAR(64) NULL,
        user_agent VARCHAR(1024) NULL,
        request_id VARCHAR(100) NULL,
        CONSTRAINT chk_audit_change_type CHECK (change_type IN ('INSERT','UPDATE','DELETE'))
      );
    foreign_keys:
      - ALTER TABLE audit_log ADD CONSTRAINT fk_audit_log_user FOREIGN KEY (changed_by) REFERENCES users(id) ON DELETE SET NULL
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_audit_table_record ON audit_log (table_name, record_id, changed_at)
      - CREATE INDEX IF NOT EXISTS idx_audit_changed_at   ON audit_log (changed_at)
      - CREATE INDEX IF NOT EXISTS idx_audit_request_id   ON audit_log (request_id)
  device_fingerprints:
    Crypto:
      id: passthrough
      user_id: passthrough
      fingerprint_hash:
        strategy: hmac
        context: db.hmac.device_fingerprints.fingerprint_hash
      fingerprint_hash_key_version: passthrough
      attributes: passthrough
      risk_score: passthrough
      first_seen: passthrough
      last_seen: passthrough
      last_ip_hash:
        strategy: hmac
        context: db.hmac.device_fingerprints.last_ip_hash
        write_key_version: true
        key_version_column: last_ip_key_version
      last_ip_key_version: passthrough
      created_at: passthrough
      updated_at: passthrough
    DefaultOrder: last_seen DESC
    create: |-
      CREATE TABLE IF NOT EXISTS device_fingerprints (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        user_id BIGINT NULL,
        fingerprint_hash BYTEA NOT NULL,
        fingerprint_hash_key_version VARCHAR(64) NULL,
        attributes JSONB NULL,
        risk_score SMALLINT NULL,
        first_seen TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        last_seen  TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        last_ip_hash BYTEA NULL,
        last_ip_key_version VARCHAR(64) NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT uq_device_fp UNIQUE (fingerprint_hash),
        CONSTRAINT chk_df_risk CHECK (risk_score IS NULL OR (risk_score BETWEEN 0 AND 100))
      );
    foreign_keys:
      - ALTER TABLE device_fingerprints ADD CONSTRAINT fk_df_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_df_user ON device_fingerprints (user_id)
      - CREATE INDEX IF NOT EXISTS idx_df_last_seen ON device_fingerprints (last_seen)
      - CREATE INDEX IF NOT EXISTS idx_df_user_last_seen ON device_fingerprints (user_id, last_seen)
    Upsert:
      Update:
        - user_id
        - attributes
        - risk_score
        - last_seen
        - last_ip_hash
        - last_ip_key_version
      Keys:
        - fingerprint_hash
  key_usage:
    Crypto:
      id: passthrough
      key_id: passthrough
      usage_date: passthrough
      encrypt_count: passthrough
      decrypt_count: passthrough
      verify_count: passthrough
      last_used_at: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS key_usage (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        key_id BIGINT NOT NULL,
        usage_date DATE NOT NULL,
        encrypt_count INTEGER NOT NULL DEFAULT 0,
        decrypt_count INTEGER NOT NULL DEFAULT 0,
        verify_count  INTEGER NOT NULL DEFAULT 0,
        last_used_at TIMESTAMPTZ(6) NULL,
        CONSTRAINT chk_key_usage_counts CHECK (
          encrypt_count >= 0 AND decrypt_count >= 0 AND verify_count >= 0
        ),
        CONSTRAINT uq_key_usage_key_date UNIQUE (key_id, usage_date)
      );
    DefaultOrder: usage_date DESC
    Aliases:
      date: usage_date
    Upsert:
      Update:
        - encrypt_count
        - decrypt_count
        - verify_count
        - last_used_at
      Keys:
        - key_id
        - usage_date
    indexes:
    foreign_keys:
      - ALTER TABLE key_usage ADD CONSTRAINT fk_key_usage_key FOREIGN KEY (key_id) REFERENCES crypto_keys(id) ON DELETE CASCADE
  rbac_repo_snapshots:
    Crypto:
      id: passthrough
      repo_id: passthrough
      commit_id: passthrough
      taken_at: passthrough
      metadata: passthrough
    DefaultOrder: taken_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS rbac_repo_snapshots (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        repo_id BIGINT NOT NULL,
        commit_id VARCHAR(128) NOT NULL,
        taken_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        metadata JSONB NULL,
        CONSTRAINT uq_rbac_repo_snap UNIQUE (repo_id, commit_id)
      );
    foreign_keys:
      - ALTER TABLE rbac_repo_snapshots ADD CONSTRAINT fk_rbac_snap_repo FOREIGN KEY (repo_id) REFERENCES rbac_repositories(id) ON DELETE CASCADE
    indexes:
    Upsert:
      Update:
        - taken_at
        - metadata
      Keys:
        - repo_id
        - commit_id
  jwt_tokens:
    Crypto:
      id: passthrough
      jti: passthrough
      user_id: passthrough
      token_hash:
        strategy: hmac
        context: db.hmac.jwt_tokens.token_hash
        write_key_version: true
        key_version_column: token_hash_key_version
      token_hash_algo: passthrough
      token_hash_key_version: passthrough
      type: passthrough
      scopes: passthrough
      created_at: passthrough
      version: passthrough
      expires_at: passthrough
      last_used_at: passthrough
      ip_hash:
        strategy: hmac
        context: db.hmac.jwt_tokens.ip_hash
        write_key_version: true
        key_version_column: ip_hash_key_version
      ip_hash_key_version: passthrough
      replaced_by: passthrough
      revoked: passthrough
      meta: passthrough
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS jwt_tokens (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        jti CHAR(36) NOT NULL UNIQUE,
        user_id BIGINT NULL,
        token_hash BYTEA NOT NULL,
        token_hash_algo VARCHAR(50) NULL,
        token_hash_key_version VARCHAR(64) NULL,
        type TEXT NOT NULL DEFAULT 'refresh',
        scopes VARCHAR(255) NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        version INTEGER NOT NULL DEFAULT 0,
        CONSTRAINT chk_jwt_tokens_version CHECK (version >= 0),
        expires_at TIMESTAMPTZ(6) NULL,
        last_used_at TIMESTAMPTZ(6) NULL,
        ip_hash BYTEA NULL,
        ip_hash_key_version VARCHAR(64) NULL,
        replaced_by BIGINT NULL,
        revoked BOOLEAN NOT NULL DEFAULT FALSE,
        meta JSONB NULL,
        CONSTRAINT uq_jwt_token_hash UNIQUE (token_hash),
        CONSTRAINT chk_jwt_type CHECK (type IN ('refresh','api')),
        CONSTRAINT chk_jwt_expires_after_created CHECK (expires_at IS NULL OR expires_at >= created_at)
      );
    foreign_keys:
      - ALTER TABLE jwt_tokens ADD CONSTRAINT fk_jwt_tokens_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL
      - ALTER TABLE jwt_tokens ADD CONSTRAINT fk_jwt_tokens_replaced_by FOREIGN KEY (replaced_by) REFERENCES jwt_tokens(id) ON DELETE SET NULL
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_jwt_user ON jwt_tokens (user_id)
      - CREATE INDEX IF NOT EXISTS idx_jwt_expires ON jwt_tokens (expires_at)
      - CREATE INDEX IF NOT EXISTS idx_jwt_revoked_user ON jwt_tokens (revoked, user_id)
      - CREATE INDEX IF NOT EXISTS idx_jwt_last_used ON jwt_tokens (last_used_at)
      - CREATE INDEX IF NOT EXISTS idx_jwt_replaced_by ON jwt_tokens (replaced_by)
      - CREATE INDEX IF NOT EXISTS idx_jwt_active_sweep ON jwt_tokens (revoked, expires_at)
    Upsert:
      Update:
        - jti
        - user_id
        - token_hash_algo
        - token_hash_key_version
        - type
        - scopes
        - expires_at
        - last_used_at
        - ip_hash
        - ip_hash_key_version
        - replaced_by
        - revoked
        - meta
      Keys:
        - token_hash
  app_settings:
    Crypto:
      setting_key: passthrough
      setting_value: passthrough
      type: passthrough
      section: passthrough
      description: passthrough
      is_protected: passthrough
      updated_at: passthrough
      version: passthrough
      updated_by: passthrough
    create: |-
      CREATE TABLE IF NOT EXISTS app_settings (
        setting_key VARCHAR(100) PRIMARY KEY,
        setting_value TEXT NULL,
        "type" TEXT NOT NULL,
        section VARCHAR(100) NULL,
        description TEXT NULL,
        is_protected BOOLEAN NOT NULL DEFAULT FALSE,
        updated_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        version INTEGER NOT NULL DEFAULT 0,
        CONSTRAINT chk_app_settings_version CHECK (version >= 0),
        updated_by BIGINT NULL,
        CONSTRAINT chk_app_settings_type CHECK ("type" IN ('string','int','bool','json','secret'))
      );
    UpdatedAt: updated_at
    DefaultOrder: setting_key ASC
    Upsert:
      Update:
        - setting_value
        - type
        - section
        - description
        - is_protected
        - updated_by
        - updated_at
        - version
      Keys:
        - setting_key
    indexes:
    foreign_keys:
      - ALTER TABLE app_settings ADD CONSTRAINT fk_app_settings_user FOREIGN KEY (updated_by) REFERENCES users(id) ON DELETE SET NULL
  session_audit:
    Crypto:
      id: passthrough
      session_token_hash:
        strategy: hmac
        context: db.hmac.session_audit.session_token_hash
        write_key_version: true
        key_version_column: session_token_key_version
      session_token_key_version: passthrough
      csrf_token_hash:
        strategy: hmac
        context: db.hmac.session_audit.csrf_token_hash
        write_key_version: true
        key_version_column: csrf_key_version
      csrf_key_version: passthrough
      session_id: passthrough
      event: passthrough
      user_id: passthrough
      ip_hash:
        strategy: hmac
        context: db.hmac.session_audit.ip_hash
        write_key_version: true
        key_version_column: ip_hash_key_version
      ip_hash_key_version: passthrough
      user_agent: passthrough
      meta_json: passthrough
      outcome: passthrough
      created_at: passthrough
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS session_audit (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        session_token_hash BYTEA NULL,
        session_token_key_version VARCHAR(64) NULL,
        csrf_token_hash BYTEA NULL,
        csrf_key_version VARCHAR(64) NULL,
        session_id VARCHAR(128) NULL,
        event VARCHAR(64) NOT NULL,
        user_id BIGINT NULL,
        ip_hash BYTEA NULL,
        ip_hash_key_version VARCHAR(64) NULL,
        user_agent VARCHAR(1024) NULL,
        meta_json JSONB NULL,
        outcome VARCHAR(32) NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6)
      );
    foreign_keys:
      - ALTER TABLE session_audit ADD CONSTRAINT fk_session_audit_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_session_audit_token_hash ON session_audit (session_token_hash)
      - CREATE INDEX IF NOT EXISTS idx_session_audit_session_id ON session_audit (session_id)
      - CREATE INDEX IF NOT EXISTS idx_session_audit_user_id ON session_audit (user_id)
      - CREATE INDEX IF NOT EXISTS idx_session_audit_created_at ON session_audit (created_at)
      - CREATE INDEX IF NOT EXISTS idx_session_audit_event ON session_audit (event)
      - CREATE INDEX IF NOT EXISTS idx_session_audit_ip_hash ON session_audit (ip_hash)
      - CREATE INDEX IF NOT EXISTS idx_session_audit_ip_key ON session_audit (ip_hash_key_version)
      - CREATE INDEX IF NOT EXISTS idx_session_audit_event_time ON session_audit (event, created_at)
      - CREATE INDEX IF NOT EXISTS idx_session_audit_user_event_time ON session_audit (user_id, event, created_at)
      - CREATE INDEX IF NOT EXISTS idx_session_audit_token_time ON session_audit (session_token_hash, created_at)
      - CREATE INDEX IF NOT EXISTS gin_session_audit_meta ON session_audit USING GIN (meta_json jsonb_path_ops)
      - CREATE INDEX IF NOT EXISTS idx_session_audit_event_user_time ON session_audit (event, user_id, created_at DESC)
  data_retention_policies:
    Crypto:
      id: passthrough
      entity_table: passthrough
      field_name: passthrough
      action: passthrough
      keep_for: passthrough
      active: passthrough
      notes: passthrough
      created_at: passthrough
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS data_retention_policies (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        entity_table VARCHAR(64) NOT NULL,
        field_name   VARCHAR(64) NULL,
        action TEXT NOT NULL,                         -- 'delete','anonymize','hash','truncate'
        keep_for VARCHAR(64) NOT NULL,
        active BOOLEAN NOT NULL DEFAULT TRUE,
        notes TEXT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT chk_drp_action CHECK (action IN ('delete','anonymize','hash','truncate')),
        CONSTRAINT uq_drp_entity_scope UNIQUE (entity_table, field_name, action, keep_for)
      );
    foreign_keys:
    indexes:
      - CREATE UNIQUE INDEX IF NOT EXISTS uq_drp_entity_scope ON data_retention_policies (entity_table, field_name, action, keep_for)
      - CREATE INDEX IF NOT EXISTS idx_drp_entity ON data_retention_policies (entity_table, field_name)
      - CREATE INDEX IF NOT EXISTS idx_drp_active ON data_retention_policies (active)
    Upsert:
      Update:
        - active
        - notes
      Keys:
        - entity_table
        - field_name
        - action
        - keep_for
  crypto_standard_aliases:
    Crypto:
      alias: passthrough
      algo_id: passthrough
      notes: passthrough
      created_at: passthrough
    DefaultOrder: alias ASC
    create: |-
      CREATE TABLE IF NOT EXISTS crypto_standard_aliases (
        alias VARCHAR(120) PRIMARY KEY,                 -- e.g. 'kyber768','dilithium2','aesgcm256'
        algo_id BIGINT NOT NULL,
        notes TEXT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6)
      );
    foreign_keys:
      - ALTER TABLE crypto_standard_aliases ADD CONSTRAINT fk_crypto_alias_algo FOREIGN KEY (algo_id) REFERENCES crypto_algorithms(id) ON DELETE CASCADE
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_crypto_alias_algo ON crypto_standard_aliases (algo_id)
    Upsert:
      Update:
        - algo_id
        - notes
      Keys:
        - alias
  merkle_roots:
    Crypto:
      id: passthrough
      subject_table: passthrough
      period_start: passthrough
      period_end: passthrough
      root_hash: passthrough
      proof_uri: passthrough
      status: passthrough
      leaf_count: passthrough
      created_at: passthrough
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS merkle_roots (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        subject_table VARCHAR(64) NOT NULL,
        period_start TIMESTAMPTZ(6) NOT NULL,
        period_end   TIMESTAMPTZ(6) NOT NULL,
        root_hash BYTEA NOT NULL,
        proof_uri VARCHAR(512),
        status VARCHAR(32) NOT NULL DEFAULT 'pending',
        leaf_count BIGINT NOT NULL,
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        CONSTRAINT uq_merkle_subject_period UNIQUE (subject_table, period_start, period_end)
      );
    foreign_keys:
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_merkle_subject ON merkle_roots (subject_table)
      - CREATE INDEX IF NOT EXISTS idx_merkle_created ON merkle_roots (created_at)
    Upsert:
      Update:
        - leaf_count
        - root_hash
      Keys:
        - subject_table
        - period_start
        - period_end
  inventory_reservations:
    Crypto:
      id: passthrough
      tenant_id: passthrough
      order_id: passthrough
      book_id: passthrough
      quantity: passthrough
      reserved_until: passthrough
      status: passthrough
      created_at: passthrough
      version: passthrough
    DefaultOrder: created_at DESC
    create: |-
      CREATE TABLE IF NOT EXISTS inventory_reservations (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        tenant_id BIGINT NOT NULL,
        order_id BIGINT NULL,
        book_id BIGINT NOT NULL,
        quantity INTEGER NOT NULL,
        reserved_until TIMESTAMPTZ(6) NOT NULL,
        status TEXT NOT NULL DEFAULT 'pending',
        created_at TIMESTAMPTZ(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
        version INTEGER NOT NULL DEFAULT 0,
        CONSTRAINT chk_reservations_version CHECK (version >= 0),
        CONSTRAINT chk_res_qty CHECK (quantity > 0),
        CONSTRAINT chk_res_status CHECK (status IN ('pending','confirmed','expired','cancelled')),
        CONSTRAINT chk_res_until_after_created CHECK (reserved_until > created_at)
      );
    foreign_keys:
      - ALTER TABLE inventory_reservations ADD CONSTRAINT fk_res_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE RESTRICT
      - ALTER TABLE inventory_reservations ADD CONSTRAINT fk_res_book  FOREIGN KEY (tenant_id, book_id)  REFERENCES books(tenant_id, id)  ON DELETE CASCADE
      - ALTER TABLE inventory_reservations ADD CONSTRAINT fk_res_order FOREIGN KEY (tenant_id, order_id) REFERENCES orders(tenant_id, id) ON DELETE CASCADE
    indexes:
      - CREATE INDEX IF NOT EXISTS idx_res_book ON inventory_reservations (book_id)
      - CREATE INDEX IF NOT EXISTS idx_res_order ON inventory_reservations (order_id)
      - CREATE INDEX IF NOT EXISTS idx_res_status_until ON inventory_reservations (status, reserved_until)
      - CREATE INDEX IF NOT EXISTS idx_res_tenant_status_until ON inventory_reservations (tenant_id, status, reserved_until)
      - CREATE INDEX IF NOT EXISTS idx_inventory_reservations_order ON inventory_reservations (order_id)
      - CREATE INDEX IF NOT EXISTS idx_res_book_status ON inventory_reservations (book_id, status)
FormatVersion: 1.1
